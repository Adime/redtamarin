#summary AVMPlus File System class.

<wiki:comment>
Here we can use asdoc to document the source code.
So the rule is to document the side notes in the wiki page.

/* more in depth informations: http://code.google.com/p/redtamarin/wiki/FileSystem */
</wiki:comment>

= About =
Provides methods to access and manipulate computer files, directories, paths and data.

*class:* {{{avmplus::FileSystem}}}

*product:* redtamarin 0.3

*since:* 0.3.0

*note:*
 * this class replace `avmplus::File`
 * everything is blocking
 * no support for unicode filename yet (eg. WIN32 use `char` not `wchar`
 * it's pretty "raw", no optimizations of any kind (eg. directories traversal)
 * no support for symlink, alias, shortcut

*vocabulary:*
{{{
WIN32
  C:\user\docs\Letter.txt

POSIX
  /home/user/docs/Letter.txt 
}}}
 * *filename* : uniquely identify an entry (file or directory) stored on the file system<br>(also *path*, *filepath*, etc.)
 * *component* : a part of the `filename`
 * *root* : the first component of an absolute `filename`
 * *basename* : last component of a `filename`
 * *dirname* :  directory component of a `filename`
 * *extension* : the suffix part of the `basename` (in general starting with a `"."`)

here the different systems we have to support
{{{
WIN32
  C:\user\docs\Letter.txt
  C:/user/docs/Letter.txt
  A:Picture.jpg

POSIX
  /home/user/docs/Letter.txt
  hostname:/directorypath/resource
  smb://hostname/directorypath/resource

UNC
  \\ComputerName\SharedFolder\Resource

UNCW (Long UNC)
  \\?\UNC\ComputerName\SharedFolder\Resource
  \\?\C:\File
}}}

*references:*
 * [http://en.wikipedia.org/wiki/File_system wikipedia File System]
 * [http://en.wikipedia.org/wiki/Path_(computing) wikipedia Path]
 * [http://en.wikipedia.org/wiki/Filename wikipedia FileName]
 * [http://en.wikipedia.org/wiki/Filename_extension wikipedia Filename extension]

----

= Constants =

== currentDirectory ==
{{{
public static const currentDirectory:String
}}}
A special path component meaning "this directory".

*since:* 0.3.0


== parentDirectory ==
{{{
public static const parentDirectory:String
}}}
A special path component meaning "the parent directory".

*since:* 0.3.0


== extensionSeparator ==
{{{
public static const extensionSeparator:String
}}}
The character used to identify a file extension.

*since:* 0.3.0


= Properties =

== drives ==
<font color="red">not implemented for WIN32</font><br>
{{{
public static function get drives():Array
}}}
Returns an array of drives.

*note:*<br>
Will not work exactly the same between POSIX and WIN32<br>
<br>
with POSIX it will always returns an empty array, eg. `[  ]`<br>
<br>
with WIN32 it will returns the `active` drives letter<br>
eg. `[ "c:", "d:" ]`

*since:* 0.3.0


== lineEnding ==
{{{
public static function get lineEnding():String
}}}
The line-ending character sequence used by the host operating system.

*note:*<br>
POSIX use `"\n"`.<br>
WIN32 use `"\r\n"`.

*since:* 0.3.0


== separators ==
{{{
public static function get separators():Array
}}}
The character separators used by the operating system.

*note:*<br>
POSIX use `"/"`.<br>
WIN32 use `"\"`, tolerant of `"/"`.

*since:* 0.3.0


----

= Methods =

== exists ==
{{{
public native static function exists( filename:String ):Boolean;
}}}
Tests whether a `filename` exists.

*example:* basic usage
{{{
import avmplus.FileSystem;

if( !FileSystem.exists( "/some/dummy/file" ) )
{
    //do something
}
else
{
    //do something else
}
}}}

*since:* 0.3.0


== read ==
{{{
public native static function read( filename:String ):String;
}}}
Reads the file `filename` into memory and returns it as a String.

*since:* 0.3.0


== write ==
{{{
public native static function write( filename:String, data:String ):void;
}}}
Writes the text `data` to the file `filename`.

*since:* 0.3.0


== readByteArray ==
{{{
public native static function readByteArray( filename:String ):ByteArray;
}}}
Reads the binary file `filename` into memory and returns it as a ByteArray.

*since:* 0.3.0


== writeByteArray ==
{{{
public native static function writeByteArray( filename:String, bytes:ByteArray ):Boolean;
}}}
Writes the binary `bytes` to the file `filename` and returns true on success.

*since:* 0.3.0


== getFileMode ==
{{{
public native static function getFileMode( filename:String ):int;
}}}
Returns the `filename` mode.

*note:*<br>
Will not work exactly the same between POSIX and WIN32<br>
<br>
with POSIX you will want to get the file mode and then apply an additional mode,<br>
it's more granular as you can choose from `USR`, `GRP` and `OTH`<br>
{{{
var mode:int = FileSystem.getFileMode( "myfile.txt" ); // -r--r--r--
chmod( "myfile.txt", (mode | S_IWUSR ) );              // -rw-r--r--
}}}
<br>
with WIN32, you have only read or write access, and write imply read<br>
(you can not have a file write-only) and so by default we map<br>
the `USR` access to `GRP` and `OTH`
{{{
var mode:int = FileSystem.getFileMode( "myfile.txt" ); // -r--r--r--
chmod( "myfile.txt", (mode | S_IWUSR ) );              // -rw-rw-rw-
}}}

*since:* 0.3.0


== getFileSize ==
{{{
public native static function getFileSize( filename:String ):Number;
}}}
Returns the file `filename` size in bytes.

*since:* 0.3.0


== getDirectorySize ==
{{{
public static function getDirectorySize( filename:String, recursive:Boolean = true, includeHidden:Boolean = true ):Number
}}}
Returns the directory `filename` size in byte (adding all its files size)<br>
and if `recursive` add the size of any child directory. 

*note:*<br>
By default will count the size of hidden entries (`includeHidden=true`).<br>
By default will count the size of all sub-directories (`recursive=true`),<br>
to get the size of the current file entries without the sub-directories you need to set `recursive=false`.

*example:* basic usage
{{{
//our directory structure
/*
test3
  |_ .DS_Store
  |_ Indie Game Design Do-s and Don't-s A Manifesto.pdf
  |_ kamoshida20080315.pdf
  |_ metaprog-100928014929-phpapp01.pdf
  |_ nexusone-userguide.pdf
  |_ NTFS-3G User Guide.pdf
  |_ Obfuscation of The Standard XOR Encryption Algorithm.pdf
  |_ others
      |_ .DS_Store
      |_ flash_player_10_security.pdf
      |_ flash_player_6_security.pdf
      |_ flash_player_7_security.pdf
      |_ flash_player_8_security.pdf
      |_ flash_player_9_security.pdf
*/

//we don't include hidden entries or sub-directories
trace( "size = " + FileSystem.getDirectorySize( "test3", false, false ) + " bytes" ); //size = 15737563 bytes

//we count the hidden entries but not the sub-directories
trace( "size = " + FileSystem.getDirectorySize( "test3", false, true ) + " bytes" ); //size = 15743711 bytes

//we count both the hidden entries and sub-directories - DEFAULT
trace( "size = " + FileSystem.getDirectorySize( "test3", true, true ) + " bytes" ); //size = 19808855 bytes
//OSX Get Info - Size: 19.8 MB on disk (19,808,855 bytes) for 12 items
}}}

*since:* 0.3.0


== getLastModifiedTime ==
{{{
public native static function getLastModifiedTime( filename:String ):Date;
}}}
Returns the `filename` last modified time.

*since:* 0.3.0


== getBasenameFromPath ==
{{{
public static function getBasenameFromPath( filename:String ):String
}}}
Returns a filepath corresponding to the last path component of this<br>
`filename`, either a file or a directory.

*note:*<br>
If this `filename` already refers to the root directory,<br>
returns a filepath identifying the root directory;<br>
this is the only situation in which basename will return an absolute path.

*since:* 0.3.0


== getDirectoryFromPath ==
{{{
public static function getDirectoryFromPath( filename:String ):String
}}}
Returns the directory component of a `filename`<br>
without the trailing path separator, or an empty string on error.

*note:*<br>
The function does not check for the existence of the path,<br>
so if it is passed a directory without the trailing `"\"`,<br>
it will interpret the last component of the path as a file and chomp it.<br>
<br>
This does not support relative paths.

*since:* 0.3.0


== getExtension ==
{{{
public static function getExtension( filename:String ):String
}}}
Returns the extension of `filename`<br>
or an empty string if the file has no extension.

*since:* 0.3.0


== canAccess ==
{{{
public static function canAccess( filename:String ):Boolean
}}}
Verify if we can access the `filename`.

*since:* 0.3.0


== canWrite ==
{{{
 public static function canWrite( filename:String ):Boolean
}}}
Verify if we can write to the `filename`.

*since:* 0.3.0


== canRead ==
{{{
public static function canRead( filename:String ):Boolean
}}}
Verify if we can read the `filename`.

*since:* 0.3.0


== hasDriveLetter ==
{{{
public static function hasDriveLetter( filename:String ):Boolean
}}}
Tests if the `filename` contains a drive letter.

*since:* 0.3.0


== isRegularFile ==
{{{
public native static function isRegularFile( filename:String ):Boolean;
}}}
Test if the `filename` is a regular file.

*since:* 0.3.0


== isDirectory ==
{{{
public native static function isDirectory( filename:String ):Boolean;
}}}
Test if the `filename` is a directory.

*since:* 0.3.0


== isHidden ==
<font color="red">not implemented for WIN32 / missing parts for OSX</font><br>
{{{
public static function isHidden( filename:String ):Boolean
}}}
Tests if the `filename` is considered `hidden` by the system.

*note:*<br>
Will not work exactly the same between POSIX and WIN32<br>
<br>
with POSIX a `filename` is considered hidden<br>
if the name start with a `.` (dot)<br>
and there is a special case for OSX (TODO)<br>
<br>
with WIN32 a filename` is considered hidden<br>
if there is a `hidden` flag in the file attributes.

*since:* 0.3.0


== isEmptyDirectory ==
{{{
public static function isEmptyDirectory( filename:String ):Boolean
}}}
Tests if the `filename` is an empty directory.

*note:*<br>
for both POSIX and WIN32 that means when listing files<br>
except `"."` (dot) and `".."`(dotdot), it returns no entry.

*since:* 0.3.0


== isSymbolicLink ==
<font color="red">not implemented</font><br>
{{{
public native static function isSymbolicLink( path:String ):Boolean;
}}}
Test if the `filename` is a symbolic link.

*since:* 0.3.0


== isSeparator ==
{{{
public static function isSeparator( c:String ):Boolean
}}}
Tests if the character `c` is a separator.

*since:* 0.3.0


== isAbsolutePath ==
{{{
public static function isAbsolutePath( filename:String ):Boolean
}}}
Tests if `filename` is an absolute path.

*since:* 0.3.0


== isNotDotOrDotdot ==
{{{
public static function isNotDotOrDotdot( element:*, index:int, arr:Array ):Boolean
}}}
Utility function to filter out current directory "." and parent directory ".." from a file list.

*note:*<br>
You can not use the function by itself<br>
you need to pass it as an argument of [#listFilesWithFilter listFilesWithFilter()].

*since:* 0.3.0


== absolutePath ==
{{{
public static function absolutePath( filename:String ):String
}}}
Returns the absolute path of `filename`.

*note:*<br>
Reuse `realpath()` from [C_stdlib C.stdlib].<br>
Also the paths are normalized before getting their full path see [#normalizePath normalizePath()].

*since:* 0.3.0


== containsPath ==
{{{
public static function containsPath( parent:String, child:String ):Boolean
}}}
Returns true if `parent` contains `child`.<br>
Both paths are converted to absolute paths before doing the comparison.

*since:* 0.3.0


== copy ==
<font color="red">not implemented</font><br>
{{{
public static function copy( origin:String, destination:String, overwrite:Boolean = false ):Boolean
}}}
TODO

*since:* 0.3.0


== copyDirectory ==
{{{
public static function copyDirectory( origin:String, destination:String, overwrite:Boolean = false, includeHidden:Boolean = true, copyMode:Boolean = false ):Boolean
}}}
Recursively copy the content of an `origin` directory to a `destination` directory<br>
and returns true on success.

*note:*
By default, does not `overwrite` the destination if it already exists.<br>
By default, does copy the hidden directories and files (`includeHidden=true`).<br>
By default, does not copy the directories and files mode (`copyMode=false`).<br>
<br>
If the `destination` does not exists it will be created.
<br>
If you need to copy only the files from a directory without recursively<br>
copying the sub-directories use [#copyFiles copyFiles()].
<br>
Will throw errors if
  * if the `origin` does not exists
  * if the `destination` already exists and `overwrite=false`
  * if the `origin` is not a directory
  * if the `destination` already exists and is not a directory
  * if the `destination` is contained by the `origin`

*since:* 0.3.0


== copyFile ==
{{{
public static function copyFile( origin:String, destination:String, overwrite:Boolean = false, copyMode:Boolean = false ):Boolean
}}}
Copy an `origin` file to a `destination` file and returns true on success.

*note:*<br>
By default, does not `overwrite` the destination if it already exists.<br>
By default, does not copy the file mode (`copyMode=false`).<br>
<br>
This method does not distinguish between hidden and regular file.
<br>
Will throw errors if
  * if the `origin` does not exists
  * if the `destination` already exists and `overwrite=false`
  * if the `origin` is a directory
  * if the `destination` exists and is a directory

*since:* 0.3.0


== copyFiles ==
{{{
public static function copyFiles( origin:String, destination:String, filter:RegExp = /.*/, overwrite:Boolean = false, includeHidden:Boolean = true, copyMode:Boolean = false ):Boolean
}}}
Copy all files matching the `filter` from directory `origin`<br>
to `destination` directory and returns true on success.

*note:*<br>
By default, the regexp filter is `/.*/` (eg. all files).<br>
By default, does not `overwrite` the destination if it already exists.<br>
By default, does copy the hidden files (`includeHidden=true`).<br>
By default, does not copy the file mode (`copyMode=false`).<br>
<br>
Will throw errors if
  * if the `origin` does not exists
  * if the `destination` does not exists
  * if the `origin` is not a directory
  * if the `destination` is not a directory

*example:* copy files using wildcards
{{{
import avmplus.FileSystem;

//will copy all the files ending by .abc in the current directory to the 'test5' directory
trace( "copied = " + FileSystem.copyFiles( ".", "test5", /.*\.abc$/, true, true, true ) ); //copied = true
}}}
result
{{{
//current directory
-rw-r--r--   48036  8 Jan 20:04 builtin.abc
-rw-r--r--   29259 17 Jan 11:30 shell_toplevel.abc
-rw-r--r--   3543 11 Jan 06:49 test.abc
-rw-r--r--   226 17 Jan 11:31 test_fs.abc
-rw-r--r--   481 13 Jan 12:31 test_io.abc

//test5 directory
-rw-r--r--   48036 17 Jan 11:31 builtin.abc
-rw-r--r--   29259 17 Jan 11:31 shell_toplevel.abc
-rw-r--r--   3543 17 Jan 11:31 test.abc
-rw-r--r--   226 17 Jan 11:31 test_fs.abc
-rw-r--r--   481 17 Jan 11:31 test_io.abc
}}}

*since:* 0.3.0


== createDirectory ==
{{{
public static function createDirectory( filename:String ):Boolean
}}}
Creates the directory path from `filename`,<br>
iterates trough the path components and create the missing directories if needed.

*note:*<br>
Returns true on success, but what does it mean if it returns false ?<br>
In short, it means that `mkdir` failed, but it might have failed with `EEXIST`,<br>
or some other error due to the the directory appearing out of thin air.<br>
This can occur if two processes are trying to create the same file system tree<br>
at the same time.

*since:* 0.3.0


== listFiles ==
{{{
public native static function listFiles( filename:String, directory:Boolean = false ):Array;
}}}
Returns an array of files or directories from `filename`.

*since:* 0.3.0


== listFilesWithFilter ==
{{{
public static function listFilesWithFilter( filename:String, filter:Function, directory:Boolean = false ):Array
}}}
Returns an array of files or directories from `filename`<br>
filtered by a function.

*note:*<br>
the function should have the same signature as the one used for Array `filter()`, for ex:
{{{
public static function isNotDotOrDotdot( element:*, index:int, arr:Array ):Boolean
{
    if( (element == currentDirectory) || (element == parentDirectory) )
    {
        return false;
    }

    return true;
}
}}}

*since:* 0.3.0


== listFilesWithRegexp ==
{{{
public static function listFilesWithRegexp( filename:String, filter:RegExp, directory:Boolean = false ):Array
}}}
Returns an array of files or directories from `filename`<br>
that matches the `filter` regular expression.

*example:* basic usage
{{{
import avmplus.FileSystem;

//list all directories starting with "test"
trace( FileSystem.listFilesWithRegexp( ".", /test*/, true ).join( "\n" ) );

//list all files ending with extension "*.abc"
trace( FileSystem.listFilesWithRegexp( ".", /.*\.abc$/, false ).join( "\n" ) );
}}}

*since:* 0.3.0


== normalizePath ==
{{{
public static function normalizePath( filename:String ):String
}}}
Normalizes the separators of the `filename`.

*note:*<br>
For POSIX, all `"\"` are replaced by `"/"`.<br>
for WIN32, all `"/"` are replaced by `"\"`.

*since:* 0.3.0


== remove ==
{{{
public static function remove( filename:String, recursive:Boolean = false ):void
}}}
Removes an entry (file or directory) from the file system.

*note:*<br>
it seems redundant to have `remove`, `removeFile`, `removeDirectory`<br>
but not really, think of cases where we want to build a list of files and just go trough<br>
them deleting wether a file or directory
{{{
import avmplus.FileSystem;

//all files in this dir ending with *.abc
var list1:Array = FileSystem.listFilesWithRegexp( ".", /.*\.abc$/, false );
//all dir in this dir starting with "test"
var list2:Array = FileSystem.listFilesWithRegexp( ".", /test*/, true );

var list:Array = list1.concat( list2 );

//we delete all of our entries wether dir or file
for( var i:uint = 0; i<list.length; i++ )
{
    FileSystem.remove(  list[i], true );
}
}}}

*since:* 0.3.0


== removeFile ==
{{{
public static function removeFile( filename:String ):void
}}}
Removes a file entry from the file system.

*note:*<br>
If the entry is not a file will throw an error.

*since:* 0.3.0


== removeDirectory ==
{{{
public static function removeDirectory( filename:String, recursive:Boolean = false ):void
}}}
Removes a directory entry from the file system,<br>
if `recursive=true` delete all child entries (files and directories) first.

*note:*<br>
If the entry is not a directory will throw an error.<br>
By default, if a directory is not empty it can not be deleted.

*since:* 0.3.0


== stripTrailingSeparators ==
{{{
public static function stripTrailingSeparators( filename:String ):String
}}}
Remove trailing separators from the `filename`.

*note:*<br>
If the path is absolute, it will never be stripped any more than<br>
to refer to the absolute root directory, so `"////"` will become `"/"`, not `""`.<br>
<br>
A leading pair of a separators is never stripped, to support alternate roots.<br>
This is used to support UNC paths on Windows.

*since:* 0.3.0


== getFreeDiskSpace ==
{{{
public native static function getFreeDiskSpace( filename:String ):Number;
}}}
Returns the available disk space in bytes on the volume containing `filename`,<br>
or `-1` on failure.

*since:* 0.3.0


== getTotalDiskSpace ==
{{{
public native static function getTotalDiskSpace( filename:String ):Number;
}}}
Returns the total disk space in bytes on the volume containing `filename`,<br>
or `-1` on failure.

*since:* 0.3.0


== getUsedDiskSpace ==
{{{
public static function getUsedDiskSpace( filename:String ):Number
}}}
Returns the used disk space in bytes on the volume containing `filename`,<br>
or `-1` on failure.

*since:* 0.3.0


----

*not implemented*
 * `copyFile( origin:String, destination:String ):Boolean`
 * `copyDirectory( origin:String, destination:String ):Boolean`
 * `rename( filename:String, newname:String ):Boolean`
 * `move( filename:String, target:String ):Boolean`
 * `createDirectory( filename:String, recursive:Boolean = false ):Boolean`