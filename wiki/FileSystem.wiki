#summary AVMPlus File System class.

<wiki:comment>
Here we can use asdoc to document the source code.
So the rule is to document the side notes in the wiki page.

/* more in depth informations: http://code.google.com/p/redtamarin/wiki/FileSystem */
</wiki:comment>

= About =
Provides methods to access and manipulate computer files, directories, paths and data.

*class:* {{{avmplus::FileSystem}}}

*product:* redtamarin 0.3

*since:* 0.3.0

*note:*
 * this class replace `avmplus::File`
 * everything is blocking
 * no support for unicode filename yet (eg. WIN32 use `char` not `wchar`
 * it's pretty "raw", no optimizations of any kind (eg. directories traversal)
 * no support for symlink, alias, shortcut

*vocabulary:*
 * *filename* : uniquely identify a file or directory stored on the file system
 * *path* : part of a filename

----
= Properties =

== drives ==
<font color="red">not implemented</font><br>
{{{
public static function get drives():Array
}}}
Returns an array of drives.

*note:*<br>
Will not work exactly the same between POSIX and WIN32<br>
<br>
with POSIX it will always returns the `root` drive, eg. `[ "/" ]`<br>
<br>
with WIN32 it will returns the `active` drives letter<br>
eg. `[ "c:\", "d:\" ]`

*since:* 0.3.0


== separators ==
{{{
public static function get separators():Array
}}}
The character separators used by the operating system.

*note:*<br>
POSIX use `"/"`.<br>
WIN32 use `"\"`, tolerant of `"/"`.

*since:* 0.3.0


----

= Methods =

== exists ==
{{{
public native static function exists( filename:String ):Boolean;
}}}
Tests whether a `filename` exists.

*example:* basic usage
{{{
import avmplus.FileSystem;

if( !FileSystem.exists( "/some/dummy/file" ) )
{
    //do something
}
else
{
    //do something else
}
}}}

*since:* 0.3.0


== read ==
{{{
public native static function read( filename:String ):String;
}}}
Reads the file `filename` into memory and returns it as a String.

*since:* 0.3.0


== write ==
{{{
public native static function write( filename:String, data:String ):void;
}}}
Writes the text `data` to the file `filename`.

*since:* 0.3.0


== readByteArray ==
{{{
public native static function readByteArray( filename:String ):ByteArray;
}}}
Reads the binary file `filename` into memory and returns it as a ByteArray.

*since:* 0.3.0


== writeByteArray ==
{{{
public native static function writeByteArray( filename:String, bytes:ByteArray ):Boolean;
}}}
Writes the binary `bytes` to the file `filename` and returns true on success.

*since:* 0.3.0


== getFileMode ==
{{{
public native static function getFileMode( filename:String ):int;
}}}
Returns the `filename` mode.

*note:*<br>
Will not work exactly the same between POSIX and WIN32<br>
<br>
with POSIX you will want to get the file mode and then apply an additional mode,<br>
it's more granular as you can choose from `USR`, `GRP` and `OTH`<br>
{{{
var mode:int = FileSystem.getFileMode( "myfile.txt" ); // -r--r--r--
chmod( "myfile.txt", (mode | S_IWUSR ) );              // -rw-r--r--
}}}
<br>
with WIN32, you have only read or write access, and write imply read<br>
(you can not have a file write-only) and so by default we map<br>
the `USR` access to `GRP` and `OTH`
{{{
var mode:int = FileSystem.getFileMode( "myfile.txt" ); // -r--r--r--
chmod( "myfile.txt", (mode | S_IWUSR ) );              // -rw-rw-rw-
}}}

*since:* 0.3.0


== getLastModifiedTime ==
{{{
public native static function getLastModifiedTime( filename:String ):Date;
}}}
Returns the `filename` last modified time.

*since:* 0.3.0


== canAccess ==
{{{
public static function canAccess( filename:String ):Boolean
}}}
Verify if we can access the `filename`.

*since:* 0.3.0


== canWrite ==
{{{
 public static function canWrite( filename:String ):Boolean
}}}
Verify if we can write to the `filename`.

*since:* 0.3.0


== canRead ==
{{{
public static function canRead( filename:String ):Boolean
}}}
Verify if we can read the `filename`.

*since:* 0.3.0


== isRegularFile ==
{{{
public native static function isRegularFile( filename:String ):Boolean;
}}}
Test if the `filename` is a regular file.

*since:* 0.3.0


== isDirectory ==
{{{
public native static function isDirectory( filename:String ):Boolean;
}}}
Test if the `filename` is a directory.

*since:* 0.3.0


== isSymbolicLink ==
<font color="red">not implemented</font><br>
{{{
public native static function isSymbolicLink( path:String ):Boolean;
}}}
Test if the `filename` is a symbolic link.

*since:* 0.3.0


== isHidden ==
<font color="red">not implemented</font><br>
{{{
public static function isHidden( filename:String ):Boolean
}}}
Test if the `filename` is considered `hidden` by the system.

*note:*<br>
Will not work exactly the same between POSIX and WIN32<br>
<br>
with POSIX a `filename` is considered hidden<br>
if the name start with a `.` (dot)<br>
and there is a special case for OSX (TODO)<br>
<br>
with WIN32 a filename` is considered hidden<br>
if there is a `hidden` flag in the file attributes.

*since:* 0.3.0


== isEmptyDirectory ==
<font color="red">not implemented</font><br>
{{{
public static function isEmptyDirectory( filename:String ):Boolean
}}}
Test if the `filename` is an empty directory.

*note:*<br>
for both POSIX and WIN32 that means when listing files<br>
except `.` (dot) and `..`(dotdot), it returns no entry.

*since:* 0.3.0


== absolutePath ==
<font color="red">not implemented</font><br>
{{{
public static function absolutePath( filename:String ):String
}}}
TODO

*since:* 0.3.0


== listFiles ==
{{{
public native static function listFiles( filename:String, directory:Boolean = false ):Array;
}}}
Returns an array of files or directories from `filename`.

*since:* 0.3.0

== normalizePath ==
<font color="red">not implemented</font><br>
{{{
public static function normalizePath( filename:String ):String
}}}
TODO

*since:* 0.3.0


== getFreeDiskSpace ==
{{{
public native static function getFreeDiskSpace( filename:String ):Number;
}}}
Returns the available disk space in bytes on the volume containing `filename`,<br>
or `-1` on failure.

*since:* 0.3.0


== getTotalDiskSpace ==
{{{
public native static function getTotalDiskSpace( filename:String ):Number;
}}}
Returns the total disk space in bytes on the volume containing `filename`,<br>
or `-1` on failure.

*since:* 0.3.0


== getUsedDiskSpace ==
{{{
public static function getUsedDiskSpace( filename:String ):Number
}}}
Returns the used disk space in bytes on the volume containing `filename`,<br>
or `-1` on failure.

*since:* 0.3.0


----

*not implemented*
 * `fileSize( filename:String ):Number`
 * `directorySize( filename:String, recursive:Boolean = false ):Number`
 * `totalSize( filename:String, recursive:Boolean = false ):Number`
 * `copyFile( origin:String, destination:String ):Boolean`
 * `copyDirectory( origin:String, destination:String ):Boolean`
 * `copy( origin:String, destination:String, recursive:Boolean = false ):Boolean`
 * `rename( filename:String, newname:String ):Boolean`
 * `move( filename:String, target:String ):Boolean`
 * `createDirectory( filename:String, recursive:Boolean = false ):Boolean`
 * `removeFile( filename:String ):Boolean`
 * `removeDirectory( filename:String, recursive:Boolean = false ):Boolean`
 * `remove( filename:String, recursive:Boolean = false ):Boolean`