#summary notes about UTF-8.

== Introduction ==

You can go in a lot of details about why a system deal with Unicode this or that way,
all the nifty differences between codepages, UCS2, UCS4, UTF-8, UTF-16, UTF-32, etc.

The bottom line is you want to be able to handle different locale in a nice and easy way,
wether to read a file name in japanese, write some text in french with accents, or create/read directories in greek.

On the server side is even more important, all the browsers and HTML pages are supposed to work in UTF-8,
and from my personal experience PHP is a pain, Python is a joy, and databases is yet another problem.

== The Good ==

Tamarin by default already deal with most of the problems, you can create Latin1, UTF-8 and UTF-16 strings,
you even have a !UnicodeUtils that tell you if a UTF-8 sring is valid, convert from UTF-8 to UTF-16, etc.

In fact, it is so well done, that even without changes, you could write
{{{
trace( "となりのトトロ" );
}}}

and it would just work, it would output a nice `となりのトトロ`.

Well... in most systems, but not on Windows.

The good thing is for Linux and Mac OS X those systems adopted a "all UTF-8" approach,
so fi your string encoding can deal with UTF-8 for ex, then all the rest follow without a fuss,
you can do something like
{{{
mkdir( "となりのトトロ" );
}}}

it will just works.

== The Bad ==

Windows is a problem on itself, it does not work like that at all.

There, the concept of "all UTF-8" is not present at all, you are first and foremost using the codepage and the locale of the system defaults.

=== The C++ easy part ===

by default you use *char* to works with ANSI characters (narrow chars)<br>
and you use *wchar_t* to works with Unicode characters (wide chars).

In Tamarin we do have our own *wchar* type
{{{
/* wchar is our version of wchar_t, since wchar_t is different sizes
 on different platforms, but we want to use UTF-16 uniformly. */
typedef uint16_t wchar;
}}}

When we create strings internally we use the type *Stringp* and some macros
{{{
Stringp name; //our string variable

StUTF8String nameUTF8(name); //macro to make it a UTF-8 string
nameUTF8.c_str() //return a char type

StUTF16String nameUTF16(name); //macro to make it a UTF-16 string
nameUTF16.c_str() //return a wchar type
}}}


=== The C++ difficult part ===

The difficult is mainly Windows.

The C-Runtime Library, that we use to implement POSIX under Windows, use different functions depending if you *UNICODE* or not.

for example *mkdir()*
{{{
int _mkdir( const char *dirname );

int _wmkdir( const wchar_t *dirname );
}}}

In our case, we can directly replace *wchar_t* by *wchar*.

Now, the main problem is to translate from *char* to *wchar* and vise versa.

So, for our own POSIX system we basically implements *VMPI_mkdir()*

wether you are under Windows, Mac OS X or Linux the function signature is the same
{{{
int VMPI_mkdir( const char *path, int mode )
}}}

in our API we would call it like that
{{{
    int CSysStatClass::mkdir(Stringp path, int mode)
    {
        if (!path) {
            toplevel()->throwArgumentError(kNullArgumentError, "path");
        }

        StUTF8String pathUTF8(path);
        return VMPI_mkdir(pathUTF8.c_str(), mode);
    }
}}}

in short
  * we take a *Stringp*
  * make it a UTF-8 string
  * pass the *char* type

So, our main problem is from the inside of *VMPI_mkdir()* we need to
  * convert a *char* to a *wchar*
  * use the wide char Unicode function
  * and do that only under Windows

Here how you would do it without thinking of the Unicode
{{{
int VMPI_mkdir(const char *path, int mode)
{
    (void)mode;
    return _mkdir( path );
}
}}}

And here how to make it work with Unicode
{{{
int VMPI_mkdir(const char *path, int mode)
{
    (void)mode;

    int size_needed = MultiByteToWideChar( CP_UTF8, 0, path, -1, NULL, 0 );

    if( size_needed != 0 )
    {
        wchar* wpath = new wchar[size_needed];
        int result = MultiByteToWideChar( CP_UTF8, 0, path, -1, wpath, size_needed );
        return _wmkdir( wpath );
    }
    else
    {
        return -1;
    }
}
}}}

a bit more details
  * we use first !MultiByteToWideChar to calculate the size needed for the *wchar* buffer
  * if this return zero, the UTF-8 chain must contains some invalid chars
  * if not, then we create our *wchar* buffer with the size needed
  * then we call a second time !MultiByteToWideChar, but this time we convert the *char* `path` to a *wchar* `wpath`
  * we then use it with the function *_wmkdir()*


== The Documents ==

[http://www.utf8everywhere.org/ UTF-8 Everywhere] for some general directives.

[http://alfps.wordpress.com/2011/11/22/unicode-part-1-windows-console-io-approaches/ Unicode part 1: Windows console i/o approaches]<br>
[http://alfps.wordpress.com/2011/12/08/unicode-part-2-utf-8-stream-mode/ Unicode part 2: UTF-8 stream mode]

Those 2 pages explain the rest, eg. you need more than just converting char to wchar, you need also to deal with input encoding, output encoding, etc.


== The C Runtime Reference ==

Which functions do you have to supports ?

|| *POSIX* || *Windows (narrow)* || *Windows (wide)* ||
||  ||  ||  ||
||  ||  ||  ||
||  ||  ||  ||
|| `mkdir` || `_mkdir` || `_wmkdir` ||
||  ||  ||  ||
||  ||  ||  ||
||  ||  ||  ||