#summary notes about UTF-8.

== Introduction ==

You can go in a lot of details about why a system deal with Unicode this or that way,
all the nifty differences between codepages, UCS2, UCS4, UTF-8, UTF-16, UTF-32, etc.

The bottom line is you want to be able to handle different locale in a nice and easy way,
wether to read a file name in japanese, write some text in french with accents, or create/read directories in greek.

On the server side is even more important, all the browsers and HTML pages are supposed to work in UTF-8,
and from my personal experience PHP is a pain, Python is a joy, and databases is yet another problem.

== The Good ==

Tamarin by default already deal with most of the problems, you can create Latin1, UTF-8 and UTF-16 strings,
you even have a !UnicodeUtils that tell you if a UTF-8 sring is valid, convert from UTF-8 to UTF-16, etc.

In fact, it is so well done, that even without changes, you could write
{{{
trace( "となりのトトロ" );
}}}

and it would just work, it would output a nice `となりのトトロ`.

Well... in most systems, but not on Windows.

The good thing is for Linux and Mac OS X those systems adopted a "all UTF-8" approach,
so fi your string encoding can deal with UTF-8 for ex, then all the rest follow without a fuss,
you can do something like
{{{
mkdir( "となりのトトロ" );
}}}

it will just works.

== The Bad ==

Windows is a problem on itself, it does not work like that at all.

There, the concept of "all UTF-8" is not present at all, you are first and foremost using the codepage and the locale of the system defaults.

=== The C++ easy part ===

by default you use *char* to works with ANSI characters (narrow chars)<br>
and you use *wchar_t* to works with Unicode characters (wide chars).

In Tamarin we do have our own *wchar* type
{{{
/* wchar is our version of wchar_t, since wchar_t is different sizes
 on different platforms, but we want to use UTF-16 uniformly. */
typedef uint16_t wchar;
}}}

When we create strings internally we use the type *Stringp* and some macros
{{{
Stringp name; //our string variable

StUTF8String nameUTF8(name); //macro to make it a UTF-8 string
nameUTF8.c_str() //return a char type

StUTF16String nameUTF16(name); //macro to make it a UTF-16 string
nameUTF16.c_str() //return a wchar type
}}}


=== The C++ difficult part ===

The difficult is mainly Windows.

The C-Runtime Library, that we use to implement POSIX under Windows, use different functions depending if you *UNICODE* or not.

for example *mkdir()*
{{{
int _mkdir( const char *dirname );

int _wmkdir( const wchar_t *dirname );
}}}

In our case, we can directly replace *wchar_t* by *wchar*.

Now, the main problem is to translate from *char* to *wchar* and vise versa.

So, for our own POSIX system we basically implements *VMPI_mkdir()*

wether you are under Windows, Mac OS X or Linux the function signature is the same
{{{
int VMPI_mkdir( const char *path, int mode )
}}}

in our API we would call it like that
{{{
    int CSysStatClass::mkdir(Stringp path, int mode)
    {
        if (!path) {
            toplevel()->throwArgumentError(kNullArgumentError, "path");
        }

        StUTF8String pathUTF8(path);
        return VMPI_mkdir(pathUTF8.c_str(), mode);
    }
}}}

in short
  * we take a *Stringp*
  * make it a UTF-8 string
  * pass the *char* type

So, our main problem is from the inside of *VMPI_mkdir()* we need to
  * convert a *char* to a *wchar*
  * use the wide char Unicode function
  * and do that only under Windows

Here how you would do it without thinking of the Unicode
{{{
int VMPI_mkdir(const char *path, int mode)
{
    (void)mode;
    return _mkdir( path );
}
}}}

And here how to make it work with Unicode
{{{
int VMPI_mkdir(const char *path, int mode)
{
    (void)mode;

    int size_needed = MultiByteToWideChar( CP_UTF8, 0, path, -1, NULL, 0 );

    if( size_needed != 0 )
    {
        wchar* wpath = new wchar[size_needed];
        int result = MultiByteToWideChar( CP_UTF8, 0, path, -1, wpath, size_needed );
        return _wmkdir( wpath );
    }
    else
    {
        return -1;
    }
}
}}}

a bit more details
  * we use first !MultiByteToWideChar to calculate the size needed for the *wchar* buffer
  * if this return zero, the UTF-8 chain must contains some invalid chars
  * if not, then we create our *wchar* buffer with the size needed
  * then we call a second time !MultiByteToWideChar, but this time we convert the *char* `path` to a *wchar* `wpath`
  * we then use it with the function *_wmkdir()*

=== The Tamarin super easy part ===

With *Stringp* and the UTF8 and UTF16 macros you can make all that much simpler.

The only catch is to do it one level upper than VMPI, because you can access those macros only from !AvmCore
and you want to keep basic type like *char* and *wchar* in the VMPI part.

Now in VMPI we will add wide chars functions
{{{
int VMPI_mkdir(const char *path, int mode)
{
    (void)mode;
    return _mkdir( path );
}

int VMPI_mkdir16(const wchar *path, int mode)
{
    (void)mode;
    return _wmkdir( path );
}
}}}

pretty straightforward.

now in our API, we just need to check for WIN32 and redirect the call accordingly
{{{
    int CSysStatClass::mkdir(Stringp path, int mode)
    {
        if (!path) {
            toplevel()->throwArgumentError(kNullArgumentError, "path");
        }

        #if AVMSYSTEM_WIN32
            StUTF16String pathUTF16(path);
            return VMPI_mkdir16(pathUTF16.c_str(), mode);
        #elif
            StUTF8String pathUTF8(path);
            return VMPI_mkdir(pathUTF8.c_str(), mode);
        #endif
    }
}}}

Here we reuse the core strength of Tamarin which already do all the work for us,
converting strings to UTF8, UTF16, checking for invalid chars, etc.

On a function like `mkdir()` we can see a bit of advantages but not that much.

Let's see with another function like `getenv()` where the conversion is more complex.

let' set up VMPI
{{{
const char *VMPI_getenv(const char *env)
{
    return getenv( env );
}

const wchar *VMPI_getenv16(const wchar *env)
{
    return _wgetenv( env );
}
}}}

and now let's see the API implementation
{{{
    /*static*/ Stringp CStdlibClass::getenv(ScriptObject* self, Stringp name)
    {
        AvmCore *core = self->core();
        Toplevel* toplevel = self->toplevel();

        if( !name )
        {
            toplevel->throwArgumentError(kNullArgumentError, "name");
        }
        
        #if AVMSYSTEM_WIN32
            StUTF16String nameUTF16(name);
            const wchar * str = VMPI_getenv16( nameUTF16.c_str() );
            
            Stringp value = core->newStringUTF16( str );
            StUTF8String valueUTF8(value);
            return core->newStringUTF8( valueUTF8.c_str() );
        #elif
            StUTF8String nameUTF8(name);
            const char * str = VMPI_getenv( nameUTF8.c_str() );
            return core->newStringUTF8( str );
        #endif
    }
}}}

So here what's happening
  * we first use `VMPI_getenv16()` with a `StUTF16String`
  * but this return also a `StUTF16String`
  * we could return a *Stringp* but the internal encoding would stay UTF16
  * so we convert this UTF16 string to a `StUTF8String`
  * and we return a *Stringp* based on UTF8

Here the advantages are more obvious, it just take a couple of lines to convert from UTF8 to UTF16 to UTF8,
if we had the same code with `MultiByteToWideChar` and `WideCharToMultiByte` we would have a more complex code
and it would much prone to errors.

Conclusion is we want to use *Stringp* with the UTF8 and UTF16 macros,
it make our API calls a little less elegant but much more easier and straightforward.

== The Documents ==

[http://www.utf8everywhere.org/ UTF-8 Everywhere] for some general directives.

[http://alfps.wordpress.com/2011/11/22/unicode-part-1-windows-console-io-approaches/ Unicode part 1: Windows console i/o approaches]<br>
[http://alfps.wordpress.com/2011/12/08/unicode-part-2-utf-8-stream-mode/ Unicode part 2: UTF-8 stream mode]

Those 2 pages explain the rest, eg. you need more than just converting char to wchar, you need also to deal with input encoding, output encoding, etc.


== The C Runtime Reference ==

Which functions do you have to supports ?

|| *POSIX* || *Windows (narrow)* || *Windows (wide)* ||
|||||| stdlib.h ||
|| `system` || `system` || `_wsystem` ||
|| `getenv` || `getenv` || `_wgetenv` ||
|| `setenv` ||  ||  ||
|| `unsetenv` ||  ||  ||
|| `putenv` || `_putenv` || `_wputenv` ||
|| `atof` ||  ||  ||
|| `atoi` ||  ||  ||
|| `atol` ||  ||  ||
|| `atoll` ||  ||  ||
|| `mkdtemp` ||  ||  ||
|| `mkstemp` ||  ||  ||
|| `realpath` || `_fullpath` || `_wfullpath` ||
|| `strtod` ||  ||  ||
|| `strtof` ||  ||  ||
|| `strtol` ||  ||  ||
|| `strtold` ||  ||  ||
|| `strtoll` ||  ||  ||
|| `strtoul` ||  ||  ||
|| `strtoull` ||  ||  ||
||  ||  ||  ||
|||||| stdio.h ||
|| `fopen` || `fopen` || `_wfopen` ||
|| `freopen` || `freopen` || `_wfreopen` ||
|| `remove` || `remove` || `_wremove` ||
|| `rename` || `rename` || `_wrename` ||
|| `fputs` || `fputs` || `_fputws` ||
|| `perror` || `perror` || `_wperror` ||
|| `popen` || `_popen` || `_wpopen` ||
|| `puts` || `puts` || `_putws` ||
|| `tempnam` ||  ||  ||
|| `tmpfile` ||  ||  ||
|| `tmpnam` ||  ||  ||
||  ||  ||  ||
|||||| sys/stat.h ||
|| `chmod` || `_chmod` || `_wchmod` ||
|| `lstat` ||  ||  ||
|| `mkdir` || `_mkdir` || `_wmkdir` ||
|| `stat` || `_stat` || `_wstat` ||
||  ||  ||  ||
|||||| unistd.h ||
|| `access` || `_access` || `_waccess` ||
|| `chdir` || `_chdir` || `_wchdir` ||
|| `chown` ||  ||  ||
|| `crypt` ||  ||  ||
|| `encrypt` ||  ||  ||
|| `execl` || `_execl` || `_wexecl` ||
|| `execle` || `_execle` || `_wexecle` ||
|| `execlp` || `_execlp` || `_wexeclp` ||
|| `execv` || `_execv` || `_wexecv` ||
|| `execve` || `_execve` || `_wexecve` ||
|| `execvp` || `_execvp` || `_wexecvp` ||
|| `getcwd` || `_getcwd` || `_wgetcwd` ||
|| `link` ||  ||  ||
|| `readlink` ||  ||  ||
|| `rmdir` || `_rmdir` || `_wrmdir` ||
|| `symlink` ||  ||  ||
|| `truncate` ||  ||  ||
|| `unlink` || `_unlink` || `_wunlink` ||
||  ||  ||  ||