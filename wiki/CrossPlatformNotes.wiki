#summary notes about cross-platform C/C++.

== Introduction ==

If writing C/C++ on one Operating System can be hard,<br>
writing C/C++ for more than one Operating System is a bitch.

And when you try to do that when you are a C/C++ noob<br>
it's like trying to make ice cube in a god damn fucking hell.

So here some notes to keep my sanity :).

Oh, and I will use *xp* each time I want to mention *cross-platform*.

== Resetting data in a char array ==

Let's say you want to receive data in a buffer (char array) and while in a loop reset the data

first attempt
{{{
char buffer[1024];

buffer[0] = '\0';

//your loop
}}}

this in theory should work everywhere, as a char array contain 1 char per index,<br>
if you set the first index to be null terminated, then another function should see your char array as empty

well ...on some POSIX it is working like that, but not everywhere (not WIN32)

so yeah you really HAVE TO clean it up the proper way
{{{
char buffer[1024];

memset( &buffer, 0, sizeof(buffer) );

//your loop
}}}


== Socket Descriptor ==

Under POSIX a socket descriptor is just an `int`
{{{
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
}}}

But under Windows, Winsock use a typedef `SOCKET` defined as a `UINT_PTR`
{{{
SOCKET WSAAPI socket(
  __in  int af,
  __in  int type,
  __in  int protocol
);

//...
/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef UINT_PTR        SOCKET;
}}}

You can almost get away with it if you keep the descriptor as a private member<br>
in an abstract class `Socket`, and then use the correct type with `PosixSocket` for POSIX<br>
and `WinSocket` for WIN32.

But, at one moment or another you will have to build your socket class by passing a socket descriptor as an argument and for that to happen you have to agree on a common type (shared by your POSIX and WIN32 code).

Luckily, I found this post [http://stackoverflow.com/questions/1953639/is-it-safe-to-cast-socket-to-int-under-win64 Is it safe to cast SOCKET to int under Win64?]<br>
which mention this comment from the openSSL source code
{{{
/*
 * Even though sizeof(SOCKET) is 8, it's safe to cast it to int, because
 * the value constitutes an index in per-process table of limited size
 * and not a real pointer.
 */
}}}

and after some tests under Windows I can say:<br>
yes you can cast your `SOCKET` to `int`! (and vise versa)

here an example
{{{
    int WinSocket::Accept() const
    {
        if(!IsValid()) {
            return NULL;
        }
        
        SOCKET socket = accept(_socket, NULL, NULL);
        return (int)socket; //UINT_PTR casted to int
    }
}}}

(note: I need to test under Windows 64bit but I'm pretty confident it should work there too)