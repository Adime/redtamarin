#summary AVMPlus Socket class.

<wiki:comment>
Here we can use asdoc to document the source code.
So the rule is to document the side notes in the wiki page.

/* more in depth informations: http://code.google.com/p/redtamarin/wiki/Socket */
</wiki:comment>

= About =
Provides methods to create client and server sockets.

*class:* {{{avmplus::Socket}}}

*product:* redtamarin 0.3

*since:* 0.3.0

*note:*
 * everything is blocking and synchronous
 * `SIGPIPE` is disabled by default, and `EPIPE` error is thrown instead
 * support Stream (TCP) and Datagram (UDP) sockets
 * no support for IP v6
 * no support for events

*references:*
 * [http://en.wikipedia.org/wiki/Berkeley_sockets wikipedia Berkeley sockets]
 * [http://en.wikipedia.org/wiki/Internet_socket wikipedia Internet socket]
 * [http://en.wikipedia.org/wiki/File_descriptor wikipedia File descriptor]


----
= Statics =

== lastError ==
{{{
public native static function get lastError():int;
}}}
The last socket error.

*since:* 0.3.0


== localAddresses ==
{{{
public static function get localAddresses():Array
}}}
The list of local IP addresses.

*note:*<br>
Most of the time you will have at least two addresses:<br>
one for the loopback interface (127.0.0.1)<br>
and at least one for an external network interface.<br>
<br>
It is not at all uncommon for a single machine to have multiple network interfaces:<br>
modem, ethernet, wifi, firewire, etc.<br>
<br>
The loopback interface lets two programs running on a single machine<br>
talk to each other without involving hardware drivers.<br>

*since:* 0.3.0


== maxConnectionQueue ==
{{{
public static function get maxConnectionQueue():uint
}}}
The maximum backlog queue length supported by the OS for each socket.

*note:*<br>
Reuse `SOMAXCONN` from [C_socket C.socket].<br>
<br>
Usually the value is between `0` and `255`, and depending on the system can be quite hard to change,<br>
see [http://antohe.tripod.com/apache_surv/asg12.htm#E70E140 Apache Server Survival Guide - Listen Backlog (SOMAXCONN)]<br>
<br>
From my personal tests
  * under OS X 10.6, `SOMAXCONN = 128`
  * under Windows XP SP3, `SOMAXCONN = 5` (winsock.h) and  `SOMAXCONN = 2147483647` (eg. `0x7fffffff` winsock2.h)
  * under Ubuntu 8.04 desktop, `SOMAXCONN = ??` (TODO)

We advise to use *128* if the OS support it.

*since:* 0.3.0


== maxConcurrentConnection ==
{{{
public native static function get maxConcurrentConnection():int;
}}}
The maximum concurrent connections supported by the OS.

*note:*<br>
To create a server with concurrent connections we use the properties<br>
`readable` and `writable`, which under the hood use the `select()` function.<br>
<br>
The maximum number of socket descriptors that the `select()` function can use<br>
is determined by the `FD_SETSIZE` macro.<br>
<br>
From my personal tests
  * under OS X 10.6, `FD_SETSIZE = 1024`
  * under Windows XP SP3, `FD_SETSIZE = 64` (both winsock.h and winsock2.h)
  * under Ubuntu 8.04 desktop, `FD_SETSIZE = ??` (TODO)

To overcome this limitation, we redefined the macro to `FD_SETSIZE = 4096` for all systems,<br>
see [http://tangentsoft.net/wskfaq/advanced.html#64sockets Winsock Programmer’s FAQ 4.9 - What are the “64 sockets” limitations?].<br>
see also [http://support.microsoft.com/kb/111855 Maximum Number of Sockets an Application Can Use].<br>
<br>
So, yes in theory and depending of your server hardware (RAM), you could create a socket server
with up to 4096 simultaneous connections, but we didn't do any real tests about it.

*since:* 0.3.0


----
= Properties =

== descriptor ==
{{{
public native function get descriptor():int;
}}}
The socket descriptor.

*note:*<br>
With POSIX a socket descriptor is of the type `int`<br>
and with WIN32 a socket descriptor is of the type `HANDLE`<br>
here we took the approach to use `int` everywhere.<br>
<br>
You can not create a `[Socket object]` out of an `int`<br>
consider here the descriptor as a "unique identifier".<br>

*since:* 0.3.0


== valid ==
{{{
public function get valid():Boolean
}}}
Indicates if the socket is valid.

*note:*<br>
A `valid` socket is a socket with a positive descriptor,<br>
all `invalid` sockets have a descriptor of `-1`.<br>
<br>
How do you get an invalid socket ?<br>
either when you close the socket, the underlying handle is destroyed<br>
and so its descriptor is set to `-1`<br>
or something wrong happened during the socket instantiation<br>
which will results also in a descriptor set to `-1`.<br>

*since:* 0.3.0

== readable ==
{{{
public function get readable():Boolean
}}}
Indicates if the socket is ready for reading.

*note:*<br>
this property call under the hood the `select()` function with a timeout of `0 seconds`,<br>
that means that this is *non-blocking*.

*since:* 0.3.0


== writable ==
{{{
public function get writable():Boolean
}}}
Indicates if the socket is ready for writing.

*note:*<br>
this property call under the hood the `select()` function with a timeout of `0 seconds`,<br>
that means that this is *non-blocking*.

*since:* 0.3.0


== connected ==
{{{
public function get connected():Boolean
}}}
Indicates if the socket is connected.

*note:*<br>
By default a socket instance have no states,<br>
from there you can call methods to make this socket<br>
either a client or a server.<br>
<br>
Calling [#connect connect()] will make the socket a client<br>
and will change the connected state to `true`.<br>
<br>
Calling [#bind bind()] then [#listen listen()] will make the socket a server<br>
but will not change the connected state.<br>

*since:* 0.3.0


== bound ==
{{{
public function get bound():Boolean
}}}
Indicates if the socket is bound.

*note:*<br>
Calling [#bind bind()] will change the bound state to `true`.

*since:* 0.3.0


== listening ==
{{{
public function get listening():Boolean
}}}
Indicates if the socket is listening.

*note:*<br>
Calling [#listen listen()] will change the listening state to `true`.

*since:* 0.3.0


== type ==
{{{
public function get type():String
}}}
Returns the type of the socket.

*note:*<br>
The type can be one of those values: "raw", "stream", "datagram" or "invalid".<br>
When the type is "invalid" that means either the socket could not construct<br>
or that the socket has been destroyed.<br>
<br>
see [#Socket Socket()] constructor for more details.

*since:* 0.3.0


== reuseAddress ==
{{{
public native function get reuseAddress():Boolean;
public native function set reuseAddress( value:Boolean ):void;
}}}
Indicates if the socket address can be reused.

*note:*<br>
By default, `reuseAddress` is set to `false`.<br>
<br>
When you use [#bind bind()] to create a server<br>
sometimes you can encounter the error "Address already in use".<br>
This can happen because a previously bound socket is still hanging<br>
around in the kernel and is hogging the port.<br>
<br>
You can either wait for it to clear (about a minute),<br>
or set `reuseAddress` to `true`.

*since:* 0.3.0


== broadcast ==
{{{
public native function get broadcast():Boolean;
public native function set broadcast( value:Boolean ):void;
}}}
Indicates if the socket can broadcast.

*note:*<br>
By default, `broadcast` is set to `false`.<br>
<br>
This option set to `true` will enable an UDP socket client<br>
(only UDP, not TCP, and only IP v4)<br>
to send data to multiple hosts at the same time.<br>
<br>
For more details see [http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#broadcast Beej's Guide to Network Programming - 7.6. Broadcast Packets].

*since:* 0.3.0


== logs ==
{{{
public function get logs():Array
}}}
Returns the session logs for this socket.

*since:* 0.3.0


== local ==
{{{
public function get local():String
}}}
Local socket address and port.

*note:*<br>
Returns a string formated as "address:port".

*since:* 0.3.0


== peer ==
{{{
public function get peer():String
}}}
Peer socket address and port.

*note:*<br>
Returns a string formated as "address:port".<br>
<br>
The "peer" is the remote connection point oft his socket.

*since:* 0.3.0


----
= Methods =

== isClient ==
{{{
public function isClient():Boolean
}}}
Indicates if the socket is a TCP client.

*note:*<br>
To be a "client" the socket need to be of the *Stream* type<br>
and of the `connected` state.

*since:* 0.3.0


== isServer ==
{{{
public function isServer():Boolean
}}}
Indicates if the socket is a TCP server.

*note:*<br>
To be a "server" the socket need to be of the *Stream* type<br>
and of the `bound` and `listening` state.

*since:* 0.3.0


== Socket ==
{{{
public function Socket( family:int = -1, socktype:int = -1, protocol:int = -1 )
}}}
The Socket constructor.

*note:*<br>
Calls the `onConstruct()` function (see [#Callbacks Callbacks] section).<br>
<br>
Without arguments will create a Stream (TCP) socket by default.<br>
<br>
To create another type of socket, reuse the constants defined in [C_socket C.socket]<br>
here how to create a Datagram (UDP) socket
{{{
import avmplus.Socket;
import C.socket.*;

var udp:Socket = new Socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
}}}

When a socket is destroyed it calls the the `onDestruct()` function.

*since:* 0.3.0


== connect ==
{{{
public function connect( host:String, port:int ):void
}}}
Connect a socket.

*note:*<br>
Calls the `onConnect()` function (see [#Callbacks Callbacks] section).<br>
<br>

*since:* 0.3.0


== close ==
{{{
public function close():void
}}}
Close a socket.

*note:*<br>
Calls the `onDisconnect()` function (see [#Callbacks Callbacks] section).<br>
<br>

*since:* 0.3.0


== send ==
<font color="orange">blocking</font><br>
{{{
public function send( data:String, flags:int = 0 ):void
}}}
Send a string message on a connected socket.

*note:*<br>
Calls the `onSend()` function (see [#Callbacks Callbacks] section).<br>
<br>
Internally we loop trough the `data.length` to be sure the full data is sent, like a `sendAll()`.<br>
<br>
send/sendBinary/sendTo/sendBinaryTo supported flags
|| *Flags* || *Description* || *POSIX* || *WIN32* ||
|| MSG_DONTROUTE || [/C_socket#Socket_messages C.socket.MSG_DONTROUTE] || yes || yes ||
|| MSG_DONTWAIT || [/C_socket#Socket_messages C.socket.MSG_DONTWAIT] || yes || no ||
|| MSG_OOB || [/C_socket#Socket_messages C.socket.MSG_OOB] || yes || yes ||

*since:* 0.3.0


== sendBinary ==
<font color="orange">blocking</font><br>
{{{
public function sendBinary( data:ByteArray, flags:int = 0 ):void
}}}
Send a binary message on a connected socket.

*note:*<br>
Calls the `onSend()` function (see [#Callbacks Callbacks] section).<br>
<br>
Internally we loop trough the `data.length` to be sure the full data is sent, like a `sendAll()`.

*since:* 0.3.0


== sendTo ==
<font color="orange">blocking</font><br>
{{{
public function sendTo( host:String, port:int, data:String, flags:int = 0 ):void
}}}
Send a string message on a socket.

*note:*<br>
Calls the `onSend()` function (see [#Callbacks Callbacks] section).<br>
<br>
The full data is sent in one packet, nothing guarantee that all the data is transfered.

*since:* 0.3.0


== sendBinaryTo ==
<font color="orange">blocking</font><br>
{{{
public function sendBinaryTo( host:String, port:int, data:ByteArray, flags:int = 0 ):void
}}}
Send a binary message on a socket.

*note:*<br>
Calls the `onSend()` function (see [#Callbacks Callbacks] section).<br>
<br>
The full data is sent in one packet, nothing guarantee that all the data is transfered.

*since:* 0.3.0


== receive ==
<font color="orange">blocking</font><br>
{{{
public function receive( buffer:uint = 1024, flags:int = 0 ):String
}}}
Receive part of a string message from a connected socket.

*note:*<br>
Calls the `onReceive()` function (see [#Callbacks Callbacks] section).<br>
<br>
The data is received fragmented by the size of the `buffer`.

*since:* 0.3.0


== receiveAll ==
<font color="orange">blocking</font><br>
{{{
public function receiveAll( buffer:uint = 1024, flags:int = 0 ):String
}}}
Receive all of a string message from a connected socket.

*note:*<br>
Calls the `onReceiveAll()` function (see [#Callbacks Callbacks] section).<br>
<br>
The method loop till all the fragments are received.

*since:* 0.3.0


== receiveBinary ==
<font color="orange">blocking</font><br>
{{{
public function receiveBinary( buffer:uint = 1024, flags:int = 0 ):ByteArray
}}}
Receive part of a binary message from a connected socket.

*note:*<br>
Calls the `onReceive()` function (see [#Callbacks Callbacks] section).<br>
<br>
The data is received fragmented by the size of the `buffer`.

*since:* 0.3.0


== receiveBinaryAll ==
<font color="orange">blocking</font><br>
{{{
public function receiveBinaryAll( buffer:uint = 1024, flags:int = 0 ):ByteArray
}}}
Receive all of a binary message from a connected socket.

*note:*<br>
Calls the `onReceiveAll()` function (see [#Callbacks Callbacks] section).<br>
<br>
The method loop till all the fragments are received.

*since:* 0.3.0


== receiveFrom ==
<font color="orange">blocking</font><br>
{{{
public function receiveFrom( buffer:uint = 512, flags:int = 0 ):String
}}}
Receive a string message from a socket.

*note:*<br>
Calls the `onReceive()` function (see [#Callbacks Callbacks] section).<br>
<br>
Receive as much data as the `buffer` allows.

*since:* 0.3.0


== receiveBinaryFrom ==
<font color="orange">blocking</font><br>
{{{
public function receiveBinaryFrom( buffer:uint = 512, flags:int = 0 ):ByteArray
}}}
Receive a binary message from a socket.

*note:*<br>
Calls the `onReceive()` function (see [#Callbacks Callbacks] section).<br>
<br>
Receive as much data as the `buffer` allows.

*since:* 0.3.0


== bind ==
{{{
public function bind( port:uint, host:String = "" ):Boolean
}}}
Bind a name to a socket.

*note:*<br>
Calls the `onBind()` function (see [#Callbacks Callbacks] section).<br>
<br>
By default, if you don't provide a `host` parameter,<br>
it will try to bind to the loopback address (`127.0.0.1`).<br>
<br>
You can only `bind()`to a local adress, see [#localAddresses localAddresses].

*since:* 0.3.0


== listen ==
{{{
public function listen( backlog:uint = 0 ):Boolean
}}}
Listen for socket connections and limit the queue of incoming connections.

*note:*<br>
Calls the `onListen()` function (see [#Callbacks Callbacks] section).<br>
<br>
By default, if you don't provide a `backlog` parameter,<br>
the server will discard queued incoming connections (eg. `backlog=0`).<br>
<br>
The maximum `backlog` queue you can use can be found in [maxConnectionQueue #maxConnectionQueue].

*since:* 0.3.0


== accept ==
<font color="orange">blocking</font><br>
{{{
public function accept():Socket
}}}
Accept a new connection on a socket.

*note:*<br>
Calls the `onAccept()` function (see [#Callbacks Callbacks] section).<br>
<br>
If you need to be able to accept simultaneous connections,<br>
you will have to create a loop and test the [#readable readable]/[#writable writable]<br>
properties of the sockets.<br>
<br>
See the examples in the [Examples_Socket socket programming guide].

*since:* 0.3.0


----
= Callbacks =

You can customize (overwrite,add more, remove, etc.) any callbacks<br>
see [http://code.google.com/p/redtamarin/wiki/Examples_Socket#Events_and_Logs socket programming guide - Events and Logs].<br>

== log ==
{{{
prototype.log = function( message:String ):void
{
    this._logs.push( message );
}
}}}
Save a log message.

*since:* 0.3.0


== output ==
{{{
prototype.output = function( message:String ):void
{
    trace( message );
}
}}}
Display a message.

*since:* 0.3.0


== recordLogOnly ==
{{{
prototype.recordLogOnly = function( message:String ):void
{
    message = "Socket (" + this.descriptor + "): " + message;
    this.log( message );
}
}}}
Record only a to the logs.

*since:* 0.3.0


== recordOutputOnly ==
{{{
prototype.recordOutputOnly = function( message:String ):void
{
    message = "Socket (" + this.descriptor + "): " + message;
    this.output( message );
}
}}}
Record only to the output.

*since:* 0.3.0


== recordAll ==
{{{
prototype.recordAll = function( message:String ):void
{
    message = "Socket (" + this.descriptor + "): " + message;
    this.log( message );
    this.output( message );
}
}}}
Record both to the logs and to the output.

*since:* 0.3.0


== record ==
{{{
prototype.record = prototype.recordAll;
}}}
Default function to *record* a message.

*since:* 0.3.0


== onConstruct ==
{{{
prototype.onConstruct = function():void
{
    this.record( this.type + " socket created." );
}
}}}
When a socket instance is created..

*since:* 0.3.0


== onDestruct ==
{{{
prototype.onDestruct = function():void
{
    this.record( this.type + " socket destroyed." );
}
}}}
When the socket instance is destroyed.

*since:* 0.3.0


== onConnect ==
{{{
prototype.onConnect = function():void
{
    this.record( "[" + this.local + "] connected to [" + this.peer + "]." );
}
}}}
When the socket connect to a peer.

*since:* 0.3.0


== onDisconnect ==
{{{
prototype.onDisconnect = function( message:String = "" ):void
{
    if( message != "" ) { this.record( message ); }
    if( this.isClient() )
    {
        this.record( "Disconnected from [" + this.peer + "]." );
    }
    else if( this.isServer() )
    {
        this.record( "[" + this.local + "] stop listening, unbound and disconnected." );
    }
}
}}}
When the socket disconnect from the peer.

*note:*<br>
The disconnection can be one of two things
  * the remote client disconnected
  * the local socket closed

*since:* 0.3.0


== onSend ==
{{{
prototype.onSend = function( data:Number ):void
{
    this.record( "Sent " + data + " bytes." );
}
}}}
When the socket send all the data.

*since:* 0.3.0


== onReceive ==
{{{
prototype.onReceive = function( data:Number ):void
{
    this.record( "Received " + data + " bytes." );
}
}}}
When the socket receive data fragments.

*since:* 0.3.0


== onReceiveAll ==
{{{
prototype.onReceiveAll = function( data:Number ):void
{
    this.record( "Received all " + data + " bytes." );
}
}}}
When the socket receive all the data.
*since:* 0.3.0


== onBind ==
{{{
prototype.onBind = function( port:uint ):void
{
    var info:String = String(port);

    if( this.local != "" ) { info = this.local; }

    this.record( "Bound to [" + info + "]." );
}
}}}
When the socket bind to an interface.

*since:* 0.3.0


== onListen ==
{{{
prototype.onListen = function( backlog:uint ):void
{
    this.record( "[" + this.local + "] listening (backlog=" + backlog + ")." );
}
}}}
When the socket listen (and so become a server).

*since:* 0.3.0


== onAccept ==
{{{
prototype.onAccept = function( id:int ):void
{
    this.record( "[" + this.local + "] accept connection from [" + id + "]." );
}
}}}
When the socket accept another socket connection.

*since:* 0.3.0


----