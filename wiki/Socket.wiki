#summary AVMPlus Socket class.

<wiki:comment>
Here we can use asdoc to document the source code.
So the rule is to document the side notes in the wiki page.

/* more in depth informations: http://code.google.com/p/redtamarin/wiki/Socket */
</wiki:comment>

= About =
Provides methods to create client and server sockets.

*class:* {{{avmplus::Socket}}}

*product:* redtamarin 0.3

*since:* 0.3.0

*note:*
 * everything is blocking and synchronous
 * `SIGPIPE` is disabled by default, and `EPIPE` error is thrown instead
 * support Stream (TCP) and Datagram (UDP) sockets
 * no support for IP v6
 * no support for events

*references:*
 * [http://en.wikipedia.org/wiki/Berkeley_sockets wikipedia Berkeley sockets]
 * [http://en.wikipedia.org/wiki/Internet_socket wikipedia Internet socket]
 * [http://en.wikipedia.org/wiki/File_descriptor wikipedia File descriptor]


----
= Statics =

== lastError ==
{{{
public native static function get lastError():int;
}}}
The last socket error.

*since:* 0.3.0


== localAddresses ==
{{{
public static function get localAddresses():Array
}}}
The list of local IP addresses.

*note:*<br>
Most of the time you will have at least two addresses:<br>
one for the loopback interface (127.0.0.1)<br>
and at least one for an external network interface.<br>
<br>
It is not at all uncommon for a single machine to have multiple network interfaces:<br>
modem, ethernet, wifi, firewire, etc.<br>
<br>
The loopback interface lets two programs running on a single machine<br>
talk to each other without involving hardware drivers.<br>

*since:* 0.3.0


== maxConnectionQueue ==
{{{
public static function get maxConnectionQueue():uint
}}}
The maximum backlog queue length supported by the OS for each socket.

*note:*<br>
Reuse `SOMAXCONN` from [C_socket C.socket].<br>
<br>
Usually the value is between `0` and `255`, and depending on the system can be quite hard to change,<br>
see [http://antohe.tripod.com/apache_surv/asg12.htm#E70E140 Apache Server Survival Guide - Listen Backlog (SOMAXCONN)]<br>
<br>
From my personal tests
  * under OS X 10.6, `SOMAXCONN = 128`
  * under Windows XP SP3, `SOMAXCONN = ??` (TODO)
  * under Ubuntu 8.04 desktop, `SOMAXCONN = ??` (TODO)

*since:* 0.3.0


== maxConcurrentConnection ==
{{{
public native static function get maxConcurrentConnection():int;
}}}
The maximum concurrent connections supported by the OS.

*note:*<br>
To create a server with concurrent connections we use the properties<br>
`readable` and `writable`, which under the hood use the `select()` function.<br>
<br>
The maximum number of socket descriptors that the `select()` function can use<br>
is determined by the `FD_SETSIZE` macro.<br>
<br>
From my personal tests
  * under OS X 10.6, `FD_SETSIZE = 1024`
  * under Windows XP SP3, `FD_SETSIZE = 64?` (TODO)
  * under Ubuntu 8.04 desktop, `FD_SETSIZE = ??` (TODO)

To overcome this limitation, we redefined the macro to `FD_SETSIZE = 4096` for all systems,<br>
see [http://tangentsoft.net/wskfaq/advanced.html#64sockets Winsock Programmer’s FAQ 4.9 - What are the “64 sockets” limitations?].<br>
<br>
So, yes in theory and depending of your server hardware (RAM), you could create a socket server
with up to 4096 simultaneous connections, but we didn't do any real tests about it.

*since:* 0.3.0


----
= Properties =

== descriptor ==
{{{
public native function get descriptor():int;
}}}
The socket descriptor.

*note:*<br>
With POSIX a socket descriptor is of the type `int`<br>
and with WIN32 a socket descriptor is of the type `HANDLE`<br>
here we took the approach to use `int` everywhere.<br>
<br>
You can not create a `[Socket object]` out of an `int`<br>
consider here the descriptor as a "unique identifier".<br>

*since:* 0.3.0


== valid ==
{{{
public function get valid():Boolean
}}}
Indicates if the socket is valid.

*note:*<br>
A `valid` socket is a socket with a positive descriptor,<br>
all `invalid` sockets have a descriptor of `-1`.<br>
<br>
How do you get an invalid socket ?<br>
either when you close the socket, the underlying handle is destroyed<br>
and so its descriptor is set to `-1`<br>
or something wrong happened during the socket instantiation<br>
which will results also in a descriptor set to `-1`.<br>

*since:* 0.3.0

== readable ==
{{{
public function get readable():Boolean
}}}
Indicates if the socket is ready for reading.

*note:*<br>
this property call under the hood the `select()` function with a timeout of `0 seconds`,<br>
that means that this is *non-blocking*.

*since:* 0.3.0


== writable ==
{{{
public function get writable():Boolean
}}}
Indicates if the socket is ready for writing.

*note:*<br>
this property call under the hood the `select()` function with a timeout of `0 seconds`,<br>
that means that this is *non-blocking*.

*since:* 0.3.0


== connected ==
{{{
public function get connected():Boolean
}}}
Indicates if the socket is connected.

*note:*<br>
By default a socket instance have no states,<br>
from there you can call methods to make this socket<br>
either a client or a server.<br>
<br>
Calling [#connect connect()] will make the socket a client<br>
and will change the connected state to `true`.<br>
<br>
Calling [#bind bind()] then [#listen listen()] will make the socket a server<br>
but will not change the connected state.<br>

*since:* 0.3.0


== bound ==
{{{
public function get bound():Boolean
}}}
Indicates if the socket is bound.

*note:*<br>
Calling [#bind bind()] will change the bound state to `true`.

*since:* 0.3.0


== listening ==
{{{
public function get listening():Boolean
}}}
Indicates if the socket is listening.

*note:*<br>
Calling [#listen listen()] will change the listening state to `true`.

*since:* 0.3.0


== type ==
{{{
public function get type():String
}}}
Returns the type of the socket.

*note:*<br>
The type can be one of those values: "raw", "stream", "datagram" or "invalid".<br>
When the type is "invalid" that means either the socket could not construct<br>
or that the socket has been destroyed.<br>
<br>
see [#Socket Socket()] constructor for more details.

*since:* 0.3.0


== reuseAddress ==
{{{
public native function get reuseAddress():Boolean;
public native function set reuseAddress( value:Boolean ):void;
}}}
Indicates if the socket address can be reused.

*note:*<br>
By default, `reuseAddress` is set to `false`.<br>
<br>
When you use [#bind bind()] to create a server<br>
sometimes you can encounter the error "Address already in use".<br>
This can happen because a previously bound socket is still hanging<br>
around in the kernel and is hogging the port.<br>
<br>
You can either wait for it to clear (about a minute),<br>
or set `reuseAddress` to `true`.

*since:* 0.3.0


== broadcast ==
{{{
public native function get broadcast():Boolean;
public native function set broadcast( value:Boolean ):void;
}}}
Indicates if the socket can broadcast.

*note:*<br>
By default, `broadcast` is set to `false`.<br>
<br>
This option set to `true` will enable an UDP socket client<br>
(only UDP, not TCP, and only IP v4)<br>
to send data to multiple hosts at the same time.<br>
<br>
For more details see [http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#broadcast Beej's Guide to Network Programming - 7.6. Broadcast Packets].

*since:* 0.3.0


== logs ==
{{{
public function get logs():Array
}}}
Returns the session logs for this socket.

*since:* 0.3.0


== local ==
{{{
public function get local():String
}}}
Local socket address and port.

*note:*<br>
Returns a string formated as "address:port".

*since:* 0.3.0


== peer ==
{{{
public function get peer():String
}}}
Peer socket address and port.

*note:*<br>
Returns a string formated as "address:port".<br>
<br>
The "peer" is the remote connection point oft his socket.

*since:* 0.3.0


----
= Methods =

== isClient ==
{{{
public function isClient():Boolean
}}}
Indicates if the socket is a TCP client.

*note:*<br>
To be a "client" the socket need to be of the Stream type<br>
and of the `connected` state.

*since:* 0.3.0


== isServer ==
{{{
public function isServer():Boolean
}}}
Indicates if the socket is a TCP server.

*note:*<br>
To be a "client" the socket need to be of the Stream type<br>
and of the `bound` and `listening` state.

*since:* 0.3.0


== Socket ==
{{{
public function Socket( family:int = -1, socktype:int = -1, protocol:int = -1 )
}}}
The Socket constructor.

*note:*<br>
Calls the `onConstruct()` function (see [#Callbacks Callbacks] section).<br>
<br>
Without arguments will create a Stream (TCP) socket by default.<br>
<br>
To create another type of socket, reuse the constants defined in [C_socket C.socket]<br>
here how to create a Datagram (UDP) socket
{{{
import avmplus.Socket;
import C.socket.*;

var udp:Socket = new Socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
}}}


*since:* 0.3.0


== connect ==
{{{
public function connect( host:String, port:int ):void
}}}

*since:* 0.3.0

----
= Callbacks =

== onConstruct ==
{{{
prototype.onConstruct = function():void
{
    this.record( this.type + " socket created." );
}
}}}

----