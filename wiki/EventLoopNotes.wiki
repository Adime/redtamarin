#summary notes about EventLoop.

== Introduction ==

see http://en.wikipedia.org/wiki/Event_loop
{{{
In computer science, the event loop, message dispatcher, message loop, message pump, or run loop
is a programming construct that waits for and dispatches events or messages in a program.
It works by making a request to some internal or external "event provider"
(which generally blocks the request until an event has arrived),
and then it calls the relevant event handler ("dispatches the event").
The event-loop may be used in conjunction with a reactor, if the event provider follows the file interface,
which can be selected or 'polled' (the Unix system call, not actual polling).
The event loop almost always operates asynchronously with the message originator.

When the event loop forms the central control flow construct of a program, as it often does,
it may be termed the main loop or main event loop.
This title is appropriate because such an event loop is at the highest level of control within the program.
}}}


To be able to implement and use the AS3 Event system in AVMGlue,
we need to define an Event Loop.

== Sync vs Async ==

By default, redtamarin is *synchronous* (or blocking).

A program run once and then terminate.

{{{
trace( "start of the program" );

// do stuff

trace( "end of the program" );
}}}

The only way to disturb this *continuous flow* is to use a blocking function,
which can block the flow indefinitely.

{{{
trace( "start of the program" );

// do stuff

sleep( 30 ); //block the flow for 30 seconds

// do more stuff

trace( "end of the program" );
}}}

<br>
<br>


To change this behaviour to *asynchronous* (or non-blocking)<br>
we need to create a global event loop that prevent the program to terminate<br>
and which can process events.

{{{
while( true ) //prevent program termination
{
    // do stuff
    process_events(); //poll
    // do more stuff
    sleep( 1 ); // buffer a little
}
}}}

Yes, that's the irony, you have an infinite loop which is blocking your program from exiting to make it non-blocking.


== Copy the Flash/AIR event loop ==

Based on different posts and articles we can have a general idea on how this event loop is working with Flash/AIR.

[http://blog.kaourantin.net/?p=82 Timing it right] by Tinic Uro (Adobe)

<pre>
Until now the Flash Player has been using a poll based system.
Poll based means that everything which happens in the player is served
from a single thread and entry point using a periodic timer which polls the run-time.
In pseudo code the top level function in the Flash Player looked like this
</pre>

{{{
while ( sleep ( 1000/120 milliseconds ) ) {
  // Every browser provides a different timer interval
  ...
  if ( timerPending ) { // AS2 Intervals, AS3 Timers
    handleTimers();
  }
  if ( localConnectionPending ) {
    handleLocalConnection();
  }
  if ( videoFrameDue ) {
    decodeVideoFrame();
  }
  if ( audioBufferEmpty ) {
    refillAudioBuffer();
  }
  if ( nextSWFFrameDue ) {
    parseSWFFrame();
    if ( actionScriptInSWFFrame ) {
      executeActionScript();
    }
  }
  if ( needsToUpdateScreen ) {
    updateScreen();
  }
  ...
}
}}}

note: `1000/120 milliseconds = 8.3333 milliseconds`

also
<pre>
The periodic timer is not driven by the Flash Player, it is driven by the browser.
In case of Internet Explorer there is an API for this purpose. In the case of Safari on OS X
is it hard coded to 50 frames/sec.
Every browser implements this slightly differently and things become very complex
quickly once you go into details.
This has been causing a lot of frustration among designers who could never count
on a consistent cross platform behavior.
</pre>

and from [http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/utils/Timer.html#delay Timer delay asdoc]
<pre>
A delay lower than 20 milliseconds is not recommended.
Timer frequency is limited to 60 frames per second,
meaning a delay lower than 16.6 milliseconds causes runtime problems.
</pre>

We can extrapolate that Flash/AIR were using a sleep period of
`1000/60 milliseconds = 16.666 milliseconds`

in our case, we can not and don't want to reuse a periodic timer based on a browser API
and we probably want to allow users to change the sleep period, so we will reuse (as in the pseudo code above)
a hard coded sleep period.

{{{
sleep period = 1000 / N = frequency of polling // N fps

1000 / 120 =  8.333 // 120fps
1000 /  60 = 16.666 //  60fps
etc.
}}}

as a side note, the Flash player is limited to 60fps<br>
see [http://www.tekool.net/blog/2008/05/27/overriding-flash-player-60fps-limit-in-firefox-up-to-950fps-as-silverlight-2-in-bubblemark/ Overriding Flash player 60fps limit in Firefox]


Following the post we can see another way to implement this event loop
{{{
while ( sleepuntil( nextEventTime  ) OR externalEventOccured() ) {
  ...
  if ( timerPending ) { // AS2 Intervals, AS3 Timers
    handleTimers();
    nextEventTime = nextTimerTime();
  }
  if ( localConnectionPending ) {
    handleLocalConnection();
    nextEventTime = min(nextEventTime , nextLocalConnectionTime());
  }
  if ( videoFrameDue ) {
    decodeVideoFrame();
    nextEventTime = min(nextEventTime , nextVideoFrameTime());
  }
  if ( audioBufferEmpty ) {
    refillAudioBuffer();
    nextEventTime = min(nextEventTime , nextAudioRebufferTime());
  }
  if ( nextSWFFrameDue ) {
    parseSWFFrame();
    if ( actionScriptInSWFFrame ) {
      executeActionScript();
    }
    nextEventTime = min(nextEventTime , nextFrameTime());
  }
  if ( needsToUpdateScreen ) {
    updateScreen();
  }
  ...
}
}}}

with some rules
<pre>
Visible:
- SWF frame rates are limited and aligned to jiffies, i.e. 60 frames a second.
(Note that Flash Playe 10.1 Beta 3 still has an upper limit of 120 which will be changed before the final release)
- timers (AS2 Interval and AS3 Timers) are limited and aligned to jiffies.
- local connections are limited and aligned to jiffies. That means a full round trip from one SWF to another
will take at least 33 milliseconds. Some reports we get say it can be up to 40ms.
- video is NOT aligned to jiffies and can play at any frame rate. This increases video playback fidelity.

Invisible:
- SWF frame rate is clocked down to 2 frames/sec.
No rendering occurs unless the SWF becomes visible again.
- timers (AS2 Interval and AS3 Timers) are clocked down to 2 a second.
- local connections are clocked down to 2 a second.
- video is decoded (not rendered or displayed) using idle CPU time only.
- For backwards compatibility reasons we override the 2 frames/sec frame rate
to 8 frames/sec when audio is playing.
</pre>

== Previous Work to Simulate an Event Loop in Tamarin ==

Previously in Tamarin you could see in `/test/performance/canaries/`

[https://code.google.com/p/redshell/source/browse/test/performance/canaries/simpleflexapputil/playershell.as?spec=svn09c5c83eea908c195ce602623d78616612252afc&r=fec870a438a8054ec2028deffd990bcec067ba0f playershell.as] implemented by Dan Schaffer.

see [https://bugzilla.mozilla.org/show_bug.cgi?id=473985 Bug 473985 - add interactive shell capabilities to canaries/simpleflexapputil/playershell.as]

from simpleflexapp.as
{{{
include "simpleflexapputil/playershell.as"

var start:int=new Date();

loadabcfile("canaries/simpleflexapputil/avmglue_abc");
loadabcfile("canaries/simpleflexapputil/hello_frame1_abc");

objectsnames.push("_hello2_mx_managers_SystemManager");
constructobject("0");
dispatchevent("init 0");

loadabcfile("canaries/simpleflexapputil/hello_frame2_abc");

set("currentFrame 0 1");
Stage.getInstance().dispatchEvent(new Event("render"));
Stage.getInstance().dispatchEvent(new Event("render"));
Stage.getInstance().dispatchEvent(new Event("render"));
Stage.getInstance().dispatchEvent(new Event("render"));
var totaltime:int=new Date()-start;

showdisplaylist();

print("metric time "+totaltime);
}}}

Very interesting bit of code which allow us to see a glimpse of
  * how to implement a custom !EventDispatcher
  * how to run an event loop
  * even how to parse a SWF file and some of its tags (like DoABC)

== Some of Our Implementations in the Past ==

!EventDispatcher in AS2, see [https://code.google.com/p/vegas/source/browse/AS2/trunk/src/vegas/events/]<br>
in particular [https://code.google.com/p/vegas/source/browse/AS2/trunk/src/vegas/events/EventDispatcher.as EventDispatcher.as]

!EventDispatcher in JS, see [https://code.google.com/p/vegas/source/browse#svn%2FJS%2Ftrunk%2Fsrc%2Fsystem%2Fevents]!

Yep, Marc did a great work implementing W3C DOM Events Level 2/3 in JS and AS2.

== Some of Others implementation ==

[https://github.com/PrimaryFeather/Starling-Framework/blob/master/starling/src/starling/events/EventDispatcher.as Starling EventDispatcher.as]



== More Documentation on the Flash Internals ==

[http://www.senocular.com/flash/tutorials/orderofoperations/ Order of Operations in ActionScript]

[http://blog.johannest.com/2009/06/15/the-movieclip-life-cycle-revisited-from-event-added-to-event-removed_from_stage/ The MovieClip life cycle revisited. From Event.ADDED to Event.REMOVED_FROM_STAGE]

from `http://www.alanklement.com/img/fp10_timeline.gif`<br>
http://www.alanklement.com/img/fp10_timeline.gif

[http://blog.joa-ebert.com/2010/10/03/opening-the-blackbox/ Opening the Blackbox]<br>
and see [https://github.com/joa/apparat/blob/master/apparat-taas/src/main/scala/apparat/taas/frontend/abc/AbcFrontend.scala AbcFrontend.scala] for the list of interfaces to support

<pre>
The playerglobal.swc contains all classes the Flash Player knows about.
It should and it does with some minor differences. Of course it could be a bug on my end but some interfaces are missing.
And they are suspicious since they cause/have special behaviour. Have a look at the AbcFrontend code.
The Synthetic object contains part of the AST that is synthesized since those interfaces are missing in playerglobal.swc.
</pre>
{{{
IBitmapDrawable
IGraphicsFill
IGraphicsData
IGraphicsPath
IGraphicsStroke
IDynamicPropertyOutput
IDataInput
IDataOutput

and flash.net
IDataInput
IDataOutput
}}}


[http://tedpatrick.com/2005/07/19/flash-player-mental-model-the-elastic-racetrack/ Flash Player Mental Model – The Elastic Racetrack]<br>
[http://tedpatrick.com/2008/04/18/flash-player-mental-model-the-elastic-racetrack-revisited/ Flash Player Mental Model – The Elastic Racetrack Revisited]<br>
[http://www.craftymind.com/2008/04/18/updated-elastic-racetrack-for-flash-9-and-avm2/ Updated ‘Elastic Racetrack’ for Flash 9 and AVM2]

http://www.craftymind.com/wp-content/uploads/2008/04/elasticracetrackexport.png

http://www.craftymind.com/wp-content/uploads/2008/04/marshalledsliceexport.png

http://www.craftymind.com/wp-content/uploads/2008/04/framemarshalingexport.png


[http://www.adobe.com/devnet/scout/articles/understanding-flashplayer-with-scout.html Understanding Flash Player with Adobe Scout]

this must be the most comprehensible and detailed article about the internals of the flash player :)

http://wwwimages.adobe.com/www.adobe.com/content/dam/Adobe/en/devnet/scout/articles/understanding-flashplayer-with-scout/understanding-flashplayer-with-scout-fig04.png

http://wwwimages.adobe.com/www.adobe.com/content/dam/Adobe/en/devnet/scout/articles/understanding-flashplayer-with-scout/understanding-flashplayer-with-scout-fig05.png

from that we know now that we'll need a *FrameTicker* class , a *DisplayListRenderer* class and a *SWFLoader* class.



== How We Are Doing It ==

It's a work in progress, but here some basic rules
  * try to do it in AS3 and not in C/C++
  * respect the Flash/AIR API signatures but allow us to use the *AVM2* namespace to add/access special stuff
  * starts simple then go more complex
  * define an *IEventLoop*

So we start simple and gonna test only the Timer events

{{{
package shell
{
    public interface IEventLoop
    {
        
        function get frequency():uint;
        function set frequency( value:uint ):void;
        
        function get timerPending():Boolean;
        
        function handleTimers():void;
        
        function start():void
        function stop():void;
    }
}
}}}



our main loop should look like
{{{
private function _loop():void
{

    while ( sleep ( 1000/frequency ) && run )
    {
    
        if( timerPending )
        {
            handleTimers();
        }
    
    }

}
}}}

we should be able to
  * update the *frequency* dynamically
  * exit the loop manually at any time (eg. `run = false`)
  * exit the loop on an interrupt (eg. `abort()`, `exit()`, etc.)

We copy CrossBridge `AS3_GoAsync();` to kickstart the main event loop from !RedTamarin.

for example
{{{
//if we do nothing, everything run sync/blocking

//some stuff

//the program will terminate

----
//if we want to be async and non-blocking
import shell.Program;

Program.goAsync(); //will run an implementation of IEventLoop

//eg.
//Program.loop = new DefaultLoop();
//Program.loop.start();
}}}


== If We Go Native ==

Different article about implementing event loop in C/C++

[http://cr.yp.to/docs/selfpipe.html The self-pipe trick]

[http://www.win.tue.nl/~aeb/linux/lk/lk-12.html Handling of asynchronous events]

[http://stackoverflow.com/questions/282176/waitpid-equivalent-with-timeout Waitpid equivalent with timeout?]

[http://www.w3.org/TR/DOM-Level-3-Events/ Document Object Model (DOM) Level 3 Events Specification]

[http://www.w3.org/Library/ Libwww - the W3C Protocol Library]

WebIDL<br>
[http://dev.w3.org/2006/webapi/WebIDL/]<br>
  * [http://heycam.github.io/webidl/ WebIDL specification]
  * [https://github.com/heycam/webidl]

[https://code.google.com/p/es-operating-system/wiki/CplusplusDOM C++ DOM API Introduction]

[http://www.codeproject.com/Articles/18766/Create-Cross-platform-Thread-Independent-Event-Loo Create Cross-platform Thread-Independent Event Loops]