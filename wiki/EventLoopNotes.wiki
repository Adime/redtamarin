#summary notes about EventLoop.

== Introduction ==

see http://en.wikipedia.org/wiki/Event_loop
{{{
In computer science, the event loop, message dispatcher, message loop, message pump, or run loop
is a programming construct that waits for and dispatches events or messages in a program.
It works by making a request to some internal or external "event provider"
(which generally blocks the request until an event has arrived),
and then it calls the relevant event handler ("dispatches the event").
The event-loop may be used in conjunction with a reactor, if the event provider follows the file interface,
which can be selected or 'polled' (the Unix system call, not actual polling).
The event loop almost always operates asynchronously with the message originator.

When the event loop forms the central control flow construct of a program, as it often does,
it may be termed the main loop or main event loop.
This title is appropriate because such an event loop is at the highest level of control within the program.
}}}


To be able to implement and use the AS3 Event system in AVMGlue,
we need to define an Event Loop.

== Sync vs Async ==

By default, redtamarin is *synchronous* (or blocking).

A program run once and then terminate.

{{{
trace( "start of the program" );

// do stuff

trace( "end of the program" );
}}}

The only way to disturb this *continuous flow* is to use a blocking function,
which can block the flow indefinitely.

{{{
trace( "start of the program" );

// do stuff

sleep( 30 ); //block the flow for 30 seconds

// do more stuff

trace( "end of the program" );
}}}

<br>
<br>


To change this behaviour to *asynchronous* (or non-blocking)<br>
we need to create a global event loop that prevent the program to terminate<br>
and which can process events.

{{{
while( true ) //prevent program termination
{
    // do stuff
    process_events(); //poll
    // do more stuff
    sleep( 1 ); // buffer a little
}
}}}

Yes, that's the irony, you have an infinite loop which is blocking your program from exiting to make it non-blocking.


== Copy the Flash/AIR event loop ==

Based on different posts and articles we can have a general idea on how this event loop is working with Flash/AIR.

[http://blog.kaourantin.net/?p=82 Timing it right] by Tinic Uro (Adobe)

<pre>
Until now the Flash Player has been using a poll based system.

Poll based means that everything which happens in the player is served
from a single thread and entry point using a periodic timer which polls the run-time.

In pseudo code the top level function in the Flash Player looked like this
</pre>

{{{
while ( sleep ( 1000/120 milliseconds ) ) {
  // Every browser provides a different timer interval
  ...
  if ( timerPending ) { // AS2 Intervals, AS3 Timers
    handleTimers();
  }
  if ( localConnectionPending ) {
    handleLocalConnection();
  }
  if ( videoFrameDue ) {
    decodeVideoFrame();
  }
  if ( audioBufferEmpty ) {
    refillAudioBuffer();
  }
  if ( nextSWFFrameDue ) {
    parseSWFFrame();
    if ( actionScriptInSWFFrame ) {
      executeActionScript();
    }
  }
  if ( needsToUpdateScreen ) {
    updateScreen();
  }
  ...
}
}}}