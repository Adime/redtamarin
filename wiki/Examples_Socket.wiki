#summary socket programming.

== Introduction ==

Since redtamarin v0.3 we added a [Socket] class,<br>
and because programming socket can be complex,<br>
here a little guide with examples and howtos to get you started.

Here two very good ressources we used for this guide
  * [http://beej.us/guide/bgnet/ Beej's Guide to Network Programming]
  * [http://tangentsoft.net/wskfaq/ Winsock Programmer’s FAQ]


== Events and Logs ==

The [Socket] class is dynamic and define "logging" functions on its prototype.

This allow you to override any of those functions depending on your needs.

It's working like that
  * for each action method, you have an event function defined on the prototype<br>for ex: `accept()` will call `onAccept()`
  * all of these event functions call the `record()` function
  * the `record()` function dispatch a message to other functions like `log()`, `output()`

here the different record mode you can define
  * `recordLogOnly()` (the default)<br>save the messages to an array
  * `recordOutputOnly()`<br>trace the messages to the output
  * `recordAll()`<br>save the messages and trace them to the output

here how you can change how the `record()` function works
{{{
Socket.prototype.record = Socket.prototype.recordAll;
var sock:Socket = new Socket();
}}}

to disable completely the `record()` function just bind to an anonymous function
{{{
Socket.prototype.record = function() {};
var sock:Socket = new Socket();
}}}

to have a custom record function, define your own and override
{{{
import avmplus.FileSystem;
import avmplus.Socket;

Socket.prototype.recordCustom = function( message:String ):void
{
    message = "Socket (" + this.descriptor + "): " + message;
    this.log( message );
    this.output( message );

    //custom
    var file:String = "socketlogs.txt";
    var data:String = "";
    if( FileSystem.exists( file ) )
    {
        data = FileSystem.read( file );
    }
    data += message + "\n";
    FileSystem.write( file, data );
}

Socket.prototype.record = Socket.prototype.recordCustom;

var client:Socket = new Socket();
}}}

== Local IP addresses ==

On most machine you will see at least two addresses
  * one for the loopback interface `127.0.0.1`
  * one for an external network interface

But you can have more: modem, ethernet, wifi, firewire, etc.

We don;t provide access to network interfaces, subnet mask, MAC addresses, etc.<br>
but the Socket class provide the static property `Socket.localAddresses`<br>
which will list those addresses.

We basically copied the example [http://tangentsoft.net/wskfaq/examples/ipaddr.html Get the Local IP Address(es)]<br>
from the Winsock Programmer’s FAQ.

Here how we do it
{{{
        public static function get localAddresses():Array
        {
            var addresses:Array = [];
            var localhost:Array = gethostbyname( "localhost", true );
            var hostname:Array  = gethostbyname( OperatingSystem.hostname, true );

            if( localhost.length > 0 )
            {
                addresses = addresses.concat( localhost );
            }
            
            if( hostname.length > 0 )
            {
                addresses = addresses.concat( hostname );
            }
            
            return addresses;
        }
}}}

We reuse `gethostbyname()` from `C.socket`,<br>
use the option to return numeric addresses<br>
then request "localhost" and the current hostname.

Here a little test on my machine
{{{
import avmplus.Socket;

trace( "Local IP addresses:" );
trace( Socket.localAddresses.join( "\n" ) );

//output
/*
Local IP addresses:
127.0.0.1
192.168.0.2
172.16.80.1
192.168.212.1
*/
}}}

Let's compare with what I obtain if I do a `ifconfig` under OS X (`ipconfig` under Windows)
{{{
$ ifconfig
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384
	inet6 ::1 prefixlen 128 
	inet6 fe80::1%lo0 prefixlen 64 scopeid 0x1 
	inet 127.0.0.1 netmask 0xff000000 
en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
	ether 00:23:df:ff:07:22 
	inet6 fe80::223:dfff:feff:722%en0 prefixlen 64 scopeid 0x4 
	inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	media: autoselect (100baseTX <full-duplex,flow-control>)
	status: active
fw0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 4078
	lladdr d4:9a:20:ff:fe:cc:d5:6e 
	media: autoselect <full-duplex>
	status: inactive
vmnet1: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
	ether 00:50:56:c0:00:01 
	inet 172.16.80.1 netmask 0xffffff00 broadcast 172.16.80.255
vmnet8: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
	ether 00:50:56:c0:00:08 
	inet 192.168.212.1 netmask 0xffffff00 broadcast 192.168.212.255
}}}

See, not only it shows my loopback IP, but also my IP on the ethernet interface (en0),<br>
it does not trace the firewire interface (fw0) as it is not active,<br>
and it traces two different IPs for the VM I'm running (vmnet1 and vmnet8).



== Other stuff ==