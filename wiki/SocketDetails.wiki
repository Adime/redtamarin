#summary Socket implementation details.

== Introduction ==

Everything you wanted to know about socket implementation details in redtamarin.


== Details ==

You would think that something like sockets have been standardised for many years by now,
well ... not exactly.

We are basically fighting 2 battles on the same front:
  * stay cross platform
  * allow a socket server to handle thousands of clients simultaneously

Some people could decide is not worthy to have this kind of goals
but then I would kindly remember them that redtamarin has a clear
mission statement: *support the use of the AS3 language for cross-platform*.

Because of that, I can not (and don't want) to allow certain features
only for Linux, or only for Windows, or any particular Operating System;
sure the C++ implementation can change per system but the API on the AS3 side
has to be the same for every systems.


=== Cross platform sockets ===

When I started to implement `avmplus.Socket` I based the code on two things
  * [http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html Beej's Guide to Network Programming]
  * [http://code.google.com/codesearch#OAMlx_jo-ck/src/v8/src/platform.h&exact_package=chromium&l=626 Chromium sockets]

Even if Beej's guide can be considered outdated it was the straightforward approach and tone that I needed to really understand socket programming.

To avoid reinventing the wheel I looked at a lot of different socket implementations in C++ that work both for Linux and Windows,
I would not say the Chromium implementation was the perfect one, but the fact it was based on an abstract class with 2 separate implementation was fitting well the Tamarin VMPI model and I could patch what was "missing" with what I was learning from other inputs.

But just there you realize Windows world and Linux world clashes quite hard, so pretty soon I had also to refer to the
[http://tangentsoft.net/wskfaq/ Winsock Programmerâ€™s FAQ].

At the end you obtain an API based on 3 layers
{{{
//1st layer: VMPI implementation
/src/tamarin/shell
    |_ Socket.h         <- abstract class
    |_ PosixSocket.h    <- POSIX implementation
    |_ PosixSocket.cpp
    |_ WinSocket.h      <- WIN32 implementation
    |_ WinSocket.cpp

//2nd layer: Tamarin native class C++ implementation
/src/tamarin/api/shell
    |_ SocketClass.h
    |_ SocketClass.cpp

//3rd layer:  Tamarin native class AS3 implementation
/src/tamarin/as3/shell/avmplus
    |_ Socket.as 

}}}

The hardest part in all those layers is to balance how much in each layer you implement stuff so the final user (you!) has enough freedom to work with the API.

So if you compare [http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/Socket.html `flash.net::Socket`] with `avmplus::Socket`, not saying that I did a better job than Adobe, but I kept my focus on giving as much low level access to the socket as possible,
and so if you compare the two `avmplus::Socket` is much more lower level which is at the same time good and bad.

It's bad because you don't have all the luxuries of `flash.net::Socket`, no events, not based on `IDataOutput`/`IDataInput`, much less example on the web, etc.

it's good because with `avmplus::Socket` you can fully re-implements `flash.net::Socket` (without the need to have access to the native source code),
and it does not stop there, you can also fully implements `flash.net::DatagramSocket`, `flash.net::ServerSocket`, etc.

And it could be considered "better" as you can fully copy C/C++ socket examples and apply them in AS3.

for example, let's implement a basic TCP server as shown here [http://en.wikipedia.org/wiki/Berkeley_sockets#Server]
{{{
//server.as
import avmplus.System;
import avmplus.Socket;
import C.stdlib.*;
import C.socket.*;

var SocketFD:Socket = new Socket();
//you could also use
//var SocketFD:Socket = new Socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

if( !SocketFD.valid )
{
    trace( "can not create socket" );
    System.exit( EXIT_FAILURE );
}

SocketFD.bind( 1100 );
if( !SocketFD.bound )
{
    trace( "error bind failed" );
    SocketFD.close();
    System.exit( EXIT_FAILURE );
}

SocketFD.listen( 10 );
if( !SocketFD.listening )
{
    trace( "error listen failed" );
    SocketFD.close();
    System.exit( EXIT_FAILURE );
}


var ConnectFD:Socket;
for(;;)
{
    ConnectFD = SocketFD.accept();

    if( !ConnectFD.valid )
    {
        trace( "error accept failed" );
        SocketFD.close();
        System.exit( EXIT_FAILURE );
    }

    /* perform read write operations ...
    var data:String = ConnectFD.receive( buff ); */

    ConnectFD.close();

    if( Socket.lastError > 0 )
    {
        trace( Socket.getErrorMessage( Socket.lastError ) );
        System.exit( EXIT_FAILURE );
    }
}

System.exit( EXIT_SUCCESS );

}}}

you could test it like that
{{{
$ java -jar asc.jar -AS3 -strict -import builtin.abc -import toplevel.abc server.a
./redshell_d server.abc
}}}

and use netcat for the client
{{{
$ nc -v -v 127.0.0.1 1100
localhost [127.0.0.1] 1100 (mctp) open
 sent 0, rcvd 0

$ nc -v -v 127.0.0.1 1100
localhost [127.0.0.1] 1100 (mctp) open
 sent 0, rcvd 0

}}}

in the output you will see
{{{
Socket (4): stream socket created.
Socket (4): Bound to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] listening (backlog=10).
Socket (5): stream socket created.
Socket (5): [127.0.0.1:62838] connected to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] accept connection from [5].
Socket (5): Terminated.
Socket (5): Disconnected from [127.0.0.1:1100].
Socket (5): stream socket destroyed.
Socket (5): stream socket created.
Socket (5): [127.0.0.1:62840] connected to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] accept connection from [5].
Socket (5): Terminated.
Socket (5): Disconnected from [127.0.0.1:1100].
Socket (5): stream socket destroyed.
^C
}}}


Here what turned out pretty well in the implementation
  * most if not all of the [http://en.wikipedia.org/wiki/Berkeley_sockets Berkely sockets] function map to a Class
  * it works exactly the same cross platform (at least Windows, Linux Ubuntu-like, OSX; probably more but I lack ressources to test more systems)
  * the API does not hide too many stuff in the background but it still make things simpler than writing it in C

But even with that I had to make hard choices

simply because of the difference between C/C++ and AS3<br>
for example, a lot of berkely sockets function return an integer and need to be passed a `struct sockaddr_in` as arguments
and I decided to avoid that, in most case for functions like `connect()`, `bind()`, `listen()`, it makes thing easier for the user
in other cases for functions like `recv()`, `send()` it makes things harder for the implementer

in short, if some function returns `-1` to show something went wrong, I just return a boolean

Things got more interesting with functions like `recv()`<br>
so what does this function ?<br>
[http://pubs.opengroup.org/onlinepubs/007904975/functions/recv.html recv - receive a message from a connected socket]

here its signature
{{{
ssize_t recv(int socket, void *buffer, size_t length, int flags);
}}}

the problem is about the *return value*<br>
"Upon successful completion, recv() shall return the length of the message in bytes. If no messages are available to be received and the peer has performed an orderly shutdown, recv() shall return 0. Otherwise, -1 shall be returned and errno set to indicate the error."

That's where the 3 layers are important

on VMPI
{{{
    int PosixSocket::Receive(char* data, int len, int flags) const
    {
        int status = recv(_socket, data, len, flags);
        return status;
    }

    int WinSocket::Receive(char* data, int len, int flags) const
    {
        int status = recv(_socket, data, len, flags);
        return status;
    }
}}}

the implementation is the same and really basic, really the methods of the class are mainly wrappers for Berkeley sockets function.


in C++
{{{
    int SocketObject::_receive(int buffer, int flags)
    {
        int result = 0;
        char *data = new char[buffer];

        _buffer->clear(); //reset the buffer before reading
        
        result = _socket->Receive(data, buffer, flags);
        
        if(result > 0) {
            _buffer->GetByteArray().Write( data, result );
        }

        delete [] data;
        return result;
    }
}}}

`_buffer` is private to the API and used to store the received data<br>
that way the data can be retrieved later and this method can still returns an integer.

based on http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#sendrecv<br>
"recv() returns the number of bytes actually read into the buffer, or -1 on error (with errno set, accordingly.)

Wait! recv() can return 0. This can mean only one thing: the remote side has closed the connection on you! A return value of 0 is recv()'s way of letting you know this has occurred."

So the only thing I do is to check if the return value is bigger than zero,<br>
if `yes` I write the data to the buffer, if `no` I just do nothing about it<br>
yes I don't but the logic of dealing with the return value in the C++ part of the class


in AS3
{{{
        private native function _receive( buffer:int, flags:int = 0 ):int;

        public function receive( buffer:uint = 1024, flags:int = 0 ):String
        {
            if( !connected ) { return; }
            
            if( buffer < _MIN_BUFFER ) { _throwReceiveBufferError(); }

            var data:String = "";
            var result:int  = _receive( buffer, flags );
            
            if( result == 0 ) { _remoteClose(); }

            if( result <= -1 ) { _throwSocketError( lastError ); }

            var _buffer:ByteArray = _getBuffer();
                _buffer.position = 0;
            data += _buffer.readUTFBytes( result );
            
            this.onReceive( data.length );
            return data;
        }
}}}

Here we play on 2 things
  * a native method `_receive()`
  * a public method `receive()`

As you can see, the logic is all here
  * if the socket is not connect we can abort right away
  * if the custom buffer has been set to a wrong value we send an error
  * if the `_receive()` return value is zero, we know the remote party closed so we call `_remoteClose()`
  * if the `_receive()` return value is `-1`, we know there is an error and we throw an error
  * and if everything went well, we just get back our private buffer data with `_getBuffer()`
  * we even use a callback `this.onReceive( data.length );`
  * and finally simply returns the data

All that are hard choices,and yes it could have been done differently, and no there are real reasons why it has been implemented this way.

So yes, I could have done all the logic of dealing with the return value in C++, so why do it in AS3 ?<br>
  * less prone to errors (much harder to debug C++ than AS3)
  * easier to test
  * easier to change
  * maybe slightly slower if you test performance in microseconds

That's the whole purpose of those 3 layers
  * VMPI is here only to abstract the difference of implementations for different operating systems
  * C++ code are here only yo give access to those native functions
  * AS3 glue everything and define the API

In short, I do the strict minimum in C/C++ and do all the rest in AS3.

And let's say I make an implementation error on the AS3 side, you can fix it before I do,<br>
for example like that
{{{
package avmplus
{
    public class Socket2 extends Socket
    {
        public override function receive( buffer:uint = 1024, flags:int = 0 ):String
        {
            //change stuff here
        }
    }
}
}}}
I'm not sure anyone need this but if you have to go that lower level you can in theory.
