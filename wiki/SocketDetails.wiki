#summary Socket implementation details.

== Introduction ==

Everything you wanted to know about socket implementation details in redtamarin.


== Details ==

You would think that something like sockets have been standardised for many years by now,
well ... not exactly.

We are basically fighting 2 battles on the same front:
  * stay cross platform
  * allow a socket server to handle thousands of clients simultaneously

Some people could decide is not worthy to have this kind of goals
but then I would kindly remember them that redtamarin has a clear
mission statement: *support the use of the AS3 language for cross-platform*.

Because of that, I can not (and don't want) to allow certain features
only for Linux, or only for Windows, or any particular Operating System;
sure the C++ implementation can change per system but the API on the AS3 side
has to be the same for every systems.


=== Cross platform sockets ===

When I started to implement `avmplus.Socket` I based the code on two things
  * [http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html Beej's Guide to Network Programming]
  * [http://code.google.com/codesearch#OAMlx_jo-ck/src/v8/src/platform.h&exact_package=chromium&l=626 Chromium sockets]

Even if Beej's guide can be considered outdated it was the straightforward approach and tone that I needed to really understand socket programming.

To avoid reinventing the wheel I looked at a lot of different socket implementations in C++ that work both for Linux and Windows,
I would not say the Chromium implementation was the perfect one, but the fact it was based on an abstract class with 2 separate implementation was fitting well the Tamarin VMPI model and I could patch what was "missing" with what I was learning from other inputs.

But just there you realize Windows world and Linux world clashes quite hard, so pretty soon I had also to refer to the
[http://tangentsoft.net/wskfaq/ Winsock Programmerâ€™s FAQ].

At the end you obtain an API based on 3 layers
{{{
//1st layer: VMPI implementation
/src/tamarin/shell
    |_ Socket.h         <- abstract class
    |_ PosixSocket.h    <- POSIX implementation
    |_ PosixSocket.cpp
    |_ WinSocket.h      <- WIN32 implementation
    |_ WinSocket.cpp

//2nd layer: Tamarin native class C++ implementation
/src/tamarin/api/shell
    |_ SocketClass.h
    |_ SocketClass.cpp

//3rd layer:  Tamarin native class AS3 implementation
/src/tamarin/as3/shell/avmplus
    |_ Socket.as 

}}}

The hardest part in all those layers is to balance how much in each layer you implement stuff so the final user (you!) has enough freedom to work with the API.

So if you compare [http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/Socket.html `flash.net::Socket`] with `avmplus::Socket`, not saying that I did a better job than Adobe, but I kept my focus on giving as much low level access to the socket as possible,
and so if you compare the two `avmplus::Socket` is much more lower level which is at the same time good and bad.

It's bad because you don;t have all the luxuries of `flash.net::Socket`, no events, not based on `IDataOutput`/`IDataInput`, much less example on the web, etc.

it's good because with `avmplus::Socket` you can fully re-implements `flash.net::Socket` (without the need to have access to the native source code),
and it does not stop there, you can also fully implements `flash.net::DatagramSocket`, `flash.net::ServerSocket`, etc.

And it could be considered "better" as you can fully copy C/C++ socket examples and apply them in AS3.

for example, let's implement a basic TCP server as shown here [http://en.wikipedia.org/wiki/Berkeley_sockets#Server]
{{{
//server.as
import avmplus.System;
import avmplus.Socket;
import C.stdlib.*;
import C.socket.*;

var SocketFD:Socket = new Socket();
//you could also use
//var SocketFD:Socket = new Socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

if( !SocketFD.valid )
{
    trace( "can not create socket" );
    System.exit( EXIT_FAILURE );
}

SocketFD.bind( 1100 );
if( !SocketFD.bound )
{
    trace( "error bind failed" );
    SocketFD.close();
    System.exit( EXIT_FAILURE );
}

SocketFD.listen( 10 );
if( !SocketFD.listening )
{
    trace( "error listen failed" );
    SocketFD.close();
    System.exit( EXIT_FAILURE );
}



}}}