#summary Socket implementation details.

== Introduction ==

Everything you wanted to know about socket implementation details in redtamarin.


== Details ==

You would think that something like sockets have been standardised for many years by now,
well ... not exactly.

We are basically fighting 2 battles on the same front:
  * stay cross platform
  * allow a socket server to handle thousands of clients simultaneously

Some people could decide is not worthy to have this kind of goals
but then I would kindly remember them that redtamarin has a clear
mission statement: *support the use of the AS3 language for cross-platform*.

Because of that, I can not (and don't want) to allow certain features
only for Linux, or only for Windows, or any particular Operating System;
sure the C++ implementation can change per system but the API on the AS3 side
has to be the same for every systems.


=== Cross platform sockets ===

When I started to implement `avmplus.Socket` I based the code on two things
  * [http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html Beej's Guide to Network Programming]
  * [http://code.google.com/codesearch#OAMlx_jo-ck/src/v8/src/platform.h&exact_package=chromium&l=626 Chromium sockets]

Even if Beej's guide can be considered outdated it was the straightforward approach and tone that I needed to really understand socket programming.

To avoid reinventing the wheel I looked at a lot of different socket implementations in C++ that work both for Linux and Windows,
I would not say the Chromium implementation was the perfect one, but the fact it was based on an abstract class with 2 separate implementation was fitting well the Tamarin VMPI model and I could patch what was "missing" with what I was learning from other inputs.

But just there you realize Windows world and Linux world clashes quite hard, so pretty soon I had also to refer to the
[http://tangentsoft.net/wskfaq/ Winsock Programmerâ€™s FAQ].

At the end you obtain an API based on 3 layers
{{{
//1st layer: VMPI implementation
/src/tamarin/shell
    |_ Socket.h         <- abstract class
    |_ PosixSocket.h    <- POSIX implementation
    |_ PosixSocket.cpp
    |_ WinSocket.h      <- WIN32 implementation
    |_ WinSocket.cpp

//2nd layer: Tamarin native class C++ implementation
/src/tamarin/api/shell
    |_ SocketClass.h
    |_ SocketClass.cpp

//3rd layer:  Tamarin native class AS3 implementation
/src/tamarin/as3/shell/avmplus
    |_ Socket.as 

}}}

The hardest part in all those layers is to balance how much in each layer you implement stuff so the final user (you!) has enough freedom to work with the API.

So if you compare [http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/Socket.html `flash.net::Socket`] with `avmplus::Socket`, not saying that I did a better job than Adobe, but I kept my focus on giving as much low level access to the socket as possible,
and so if you compare the two `avmplus::Socket` is much more lower level which is at the same time good and bad.

It's bad because you don't have all the luxuries of `flash.net::Socket`, no events, not based on `IDataOutput`/`IDataInput`, much less example on the web, etc.

it's good because with `avmplus::Socket` you can fully re-implements `flash.net::Socket` (without the need to have access to the native source code),
and it does not stop there, you can also fully implements `flash.net::DatagramSocket`, `flash.net::ServerSocket`, etc.

And it could be considered "better" as you can fully copy C/C++ socket examples and apply them in AS3.

for example, let's implement a basic TCP server as shown here [http://en.wikipedia.org/wiki/Berkeley_sockets#Server]
{{{
//server.as
import avmplus.System;
import avmplus.Socket;
import C.stdlib.*;
import C.socket.*;

var SocketFD:Socket = new Socket();
//you could also use
//var SocketFD:Socket = new Socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

if( !SocketFD.valid )
{
    trace( "can not create socket" );
    System.exit( EXIT_FAILURE );
}

SocketFD.bind( 1100 );
if( !SocketFD.bound )
{
    trace( "error bind failed" );
    SocketFD.close();
    System.exit( EXIT_FAILURE );
}

SocketFD.listen( 10 );
if( !SocketFD.listening )
{
    trace( "error listen failed" );
    SocketFD.close();
    System.exit( EXIT_FAILURE );
}


var ConnectFD:Socket;
for(;;)
{
    ConnectFD = SocketFD.accept();

    if( !ConnectFD.valid )
    {
        trace( "error accept failed" );
        SocketFD.close();
        System.exit( EXIT_FAILURE );
    }

    /* perform read write operations ...
    var data:String = ConnectFD.receive( buff ); */

    ConnectFD.close();

    if( Socket.lastError > 0 )
    {
        trace( Socket.getErrorMessage( Socket.lastError ) );
        System.exit( EXIT_FAILURE );
    }
}

System.exit( EXIT_SUCCESS );

}}}

you could test it like that
{{{
$ java -jar asc.jar -AS3 -strict -import builtin.abc -import toplevel.abc server.a
./redshell_d server.abc
}}}

and use netcat for the client
{{{
$ nc -v -v 127.0.0.1 1100
localhost [127.0.0.1] 1100 (mctp) open
 sent 0, rcvd 0

$ nc -v -v 127.0.0.1 1100
localhost [127.0.0.1] 1100 (mctp) open
 sent 0, rcvd 0

}}}

in the output you will see
{{{
Socket (4): stream socket created.
Socket (4): Bound to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] listening (backlog=10).
Socket (5): stream socket created.
Socket (5): [127.0.0.1:62838] connected to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] accept connection from [5].
Socket (5): Terminated.
Socket (5): Disconnected from [127.0.0.1:1100].
Socket (5): stream socket destroyed.
Socket (5): stream socket created.
Socket (5): [127.0.0.1:62840] connected to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] accept connection from [5].
Socket (5): Terminated.
Socket (5): Disconnected from [127.0.0.1:1100].
Socket (5): stream socket destroyed.
^C
}}}


Here what turned out pretty well in the implementation
  * most if not all of the [http://en.wikipedia.org/wiki/Berkeley_sockets Berkely sockets] function map to a Class
  * it works exactly the same cross platform (at least Windows, Linux Ubuntu-like, OSX; probably more but I lack ressources to test more systems)
  * the API does not hide too many stuff in the background but it still make things simpler than writing it in C

But even with that I had to make hard choices

simply because of the difference between C/C++ and AS3<br>
for example, a lot of berkely sockets function return an integer and need to be passed a `struct sockaddr_in` as arguments
and I decided to avoid that, in most case for functions like `connect()`, `bind()`, `listen()`, it makes thing easier for the user
in other cases for functions like `recv()`, `send()` it makes things harder for the implementer

in short, if some function returns `-1` to show something went wrong, I just return a boolean

Things got more interesting with functions like `recv()`<br>
so what does this function ?<br>
[http://pubs.opengroup.org/onlinepubs/007904975/functions/recv.html recv - receive a message from a connected socket]

here its signature
{{{
ssize_t recv(int socket, void *buffer, size_t length, int flags);
}}}

the problem is about the *return value*<br>
"Upon successful completion, recv() shall return the length of the message in bytes. If no messages are available to be received and the peer has performed an orderly shutdown, recv() shall return 0. Otherwise, -1 shall be returned and errno set to indicate the error."

That's where the 3 layers are important

on VMPI
{{{
    int PosixSocket::Receive(char* data, int len, int flags) const
    {
        int status = recv(_socket, data, len, flags);
        return status;
    }

    int WinSocket::Receive(char* data, int len, int flags) const
    {
        int status = recv(_socket, data, len, flags);
        return status;
    }
}}}

the implementation is the same and really basic, really the methods of the class are mainly wrappers for Berkeley sockets function.


in C++
{{{
    int SocketObject::_receive(int buffer, int flags)
    {
        int result = 0;
        char *data = new char[buffer];

        _buffer->clear(); //reset the buffer before reading
        
        result = _socket->Receive(data, buffer, flags);
        
        if(result > 0) {
            _buffer->GetByteArray().Write( data, result );
        }

        delete [] data;
        return result;
    }
}}}

`_buffer` is private to the API and used to store the received data<br>
that way the data can be retrieved later and this method can still returns an integer.

based on http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html#sendrecv<br>
"recv() returns the number of bytes actually read into the buffer, or -1 on error (with errno set, accordingly.)

Wait! recv() can return 0. This can mean only one thing: the remote side has closed the connection on you! A return value of 0 is recv()'s way of letting you know this has occurred."

So the only thing I do is to check if the return value is bigger than zero,<br>
if `yes` I write the data to the buffer, if `no` I just do nothing about it<br>
yes I don't but the logic of dealing with the return value in the C++ part of the class


in AS3
{{{
        private native function _receive( buffer:int, flags:int = 0 ):int;

        public function receive( buffer:uint = 1024, flags:int = 0 ):String
        {
            if( !connected ) { return; }
            
            if( buffer < _MIN_BUFFER ) { _throwReceiveBufferError(); }

            var data:String = "";
            var result:int  = _receive( buffer, flags );
            
            if( result == 0 ) { _remoteClose(); }

            if( result <= -1 ) { _throwSocketError( lastError ); }

            var _buffer:ByteArray = _getBuffer();
                _buffer.position = 0;
            data += _buffer.readUTFBytes( result );
            
            this.onReceive( data.length );
            return data;
        }
}}}

Here we play on 2 things
  * a native method `_receive()`
  * a public method `receive()`

As you can see, the logic is all here
  * if the socket is not connect we can abort right away
  * if the custom buffer has been set to a wrong value we send an error
  * if the `_receive()` return value is zero, we know the remote party closed so we call `_remoteClose()`
  * if the `_receive()` return value is `-1`, we know there is an error and we throw an error
  * and if everything went well, we just get back our private buffer data with `_getBuffer()`
  * we even use a callback `this.onReceive( data.length );`
  * and finally simply returns the data

All that are hard choices,and yes it could have been done differently, and no there are real reasons why it has been implemented this way.

So yes, I could have done all the logic of dealing with the return value in C++, so why do it in AS3 ?<br>
  * less prone to errors (much harder to debug C++ than AS3)
  * easier to test
  * easier to change
  * maybe slightly slower if you test performance in microseconds

That's the whole purpose of those 3 layers
  * VMPI is here only to abstract the difference of implementations for different operating systems
  * C++ code are here only to give access to those native functions
  * AS3 glue everything and define the API

In short, I do the strict minimum in C/C++ and do all the rest in AS3.

And let's say I make an implementation error on the AS3 side, you can fix it before I do,<br>
for example like that
{{{
package avmplus
{
    public class Socket2 extends Socket
    {
        public override function receive( buffer:uint = 1024, flags:int = 0 ):String
        {
            //change stuff here
        }
    }
}
}}}
I'm not sure anyone need this but if you have to go that lower level you can in theory.

Another hard choice was to provide some kind of callback without an event system in place in redtamarin,<br>
you can read more about it here [http://code.google.com/p/redtamarin/wiki/Examples_Socket#Events_and_Logs Socket Events and Logs],<br>
yes by default all socket activity is logged, you can easily remove it if it gets in your way,<br>
and more interestingly you can hook your own events or callbacks to replace it<br>
(this is also where AS3 shine where you can use the prototype to customize a class).

TODO<br>
show how all that helped or influenced the implementation of `flash.net:Socket` in the lib [http://code.google.com/p/maashaack/wiki/avmglue avmglue].

TODO<br>
give more details on some operating system differences (file descriptor vs SOCKET, etc.)


=== Socket server ===

If you thought making cross platform choices were hard, making choice about the server side of sockets is even harder.

First of all, there is no fucking standard working for every operating systems,<br>
the differences between Berkeley sockets and Winsock are small potatoes compared to the huge depth of differences you can find when you try to deal will simultaneous connections.

OK, let's starts the big rant...<br>

If you're on Linux, you have `fork()`, and combined with sockets it allow you to isolate each client connections per threads and keep a rather simple code.

But there is no `fork()` on Windows, hard choice: I can not use `fork()`, period. No, I will not implement `fork()` in redtamarin and say "oh it works only for Linux".

So, one solution would be to define VMPI way of doing threads that would work for any systems: Linux, OSX, Windows, etc.<br>
but wait ... is using multithreading really the best solution to support concurrency ?

let's read [http://drdobbs.com/open-source/184405553 I/O Multiplexing & Scalable Socket Servers] from Dr Dobb's<br>
here we learn that
  * "the thread-pooling model" is simple to implement
  * "one file descriptor is added to a worker thread for the lifetime of the connection"
  * "Using a single connection per thread lets the data buffer be local on the thread stack"

with those "drawback to thread pools"
  * "The number of threads an OS can create per process"
  * "The time it takes to switch between worker threads (context switching)"
  * "Worker threads are I/O bound"

mainly that "depending on the OS and hardware, the thread-pooling model reaches the point of diminishing returns around 500 concurrent worker threads.",
and that sorry is not good enough in my book, 500 concurrent connections ? that sucks!

And then the article explains all the goodness of *I/O multiplexing*
"I/O multiplexing, on the other hand, enables an application to overlap its I/O processing with the completion of I/O operations. Applications manage overlapped I/O by processing socket handles (client connections) through events that are sent from the kernel to the application. These notify the application that I/O has completed. By using an event-based mechanism, each worker thread can process I/O from multiple clients while the underlying driver waits for I/O to complete.

An application's ability to process I/O from many clients per thread is preferential to having one client per worker thread. With one client per thread, context switches must occur each time the application needs to process I/O from another client. Adding multiple clients per worker thread enables a server application to handle a significantly larger number of clients, processing I/O for each client as soon as it is made ready by the OS. Each client is still I/O bound, but the threads are free to process any I/O available. The number of worker threads used to process the I/O should also be considerably smaller than the number used in the thread-pool model. A simple function to calculate the number of worker threads is worker threads= 2*n, where n is the number of CPUs in the server running the application."

and that little nugget
"Operating systems differ in their native support for I/O multiplexing and the effectiveness of each implementation:

UNIX-based operating systems share similar support for I/O multiplexing through the use of signals, select(), and poll() APIs, and a new device /dev/poll.

Windows supports asynchronous I/O through select(), various Windows APIs, and I/O completion ports.

Java has native I/O multiplexing in the 1.4.1 SDK through the selector API. Unfortunately, the selector API is limited to processing 64 clients per instance of the selector class.

The most efficient mechanisms for I/O multiplexing are /dev/poll for UNIX and I/O completion ports on Windows."

So by the end of the article you can read *Cross-Platform I/O Multiplexing Abstraction*,<br>
and that's basically what I want to implement for a truly efficient socket server in redtamarin,<br>
but it's not there yet.

Here basically the problem: almost every operating system do it differently, some will use `select()`, other will use `poll()`, some will have `poll()` as a wrapper around `select()`, and then there is also `epoll()`, and `/dev/poll`, and `kqueue()`, and realtime signals, and I/O completion ports, etc.

For a much detailled explanation of the problem please read [http://www.kegel.com/c10k.html The C10K problem].

TODO<br>
talk about libevent, then libev<br>
talk about why not investigate threads<br>
talk about why select() is cross platform<br>
talk about the limit of file descriptors<br>
explain the choices...