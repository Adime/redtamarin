#summary Socket implementation details.

== Introduction ==

Everything you wanted to know about socket implementation details in redtamarin.


== Details ==

You would think that something like sockets have been standardised for many years by now,
well ... not exactly.

We are basically fighting 2 battles on the same front:
  * stay cross platform
  * allow a socket server to handle thousands of clients simultaneously

Some people could decide is not worthy to have this kind of goals
but then I would kindly remember them that redtamarin has a clear
mission statement: *support the use of the AS3 language for cross-platform*.

Because of that, I can not (and don't want) to allow certain features
only for Linux, or only for Windows, or any particular Operating System;
sure the C++ implementation can change per system but the API on the AS3 side
has to be the same for every systems.


=== Cross platform sockets ===

When I started to implement `avmplus.Socket` I based the code on two things
  * [http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html Beej's Guide to Network Programming]
  * [http://code.google.com/codesearch#OAMlx_jo-ck/src/v8/src/platform.h&exact_package=chromium&l=626 Chromium sockets]

Even if Beej's guide can be considered outdated it was the straightforward approach and tone that I needed to really understand socket programming.

To avoid reinventing the wheel I looked at a lot of different socket implementations in C++ that work both for Linux and Windows,
I would not say the Chromium implementation was the perfect one, but the fact it was based on an abstract class with 2 separate implementation was fitting well the Tamarin VMPI model and I could patch what was "missing" with what I was learning from other inputs.

But just there you realize Windows world and Linux world clashes quite hard, so pretty soon I had also to refer to the
[http://tangentsoft.net/wskfaq/ Winsock Programmerâ€™s FAQ].

At the end you obtain an API based on 3 layers
{{{
//1st layer: VMPI implementation
/src/tamarin/shell
    |_ Socket.h         <- abstract class
    |_ PosixSocket.h    <- POSIX implementation
    |_ PosixSocket.cpp
    |_ WinSocket.h      <- WIN32 implementation
    |_ WinSocket.cpp

//2nd layer: Tamarin native class C++ implementation
/src/tamarin/api/shell
    |_ SocketClass.h
    |_ SocketClass.cpp

//3rd layer:  Tamarin native class AS3 implementation
/src/tamarin/as3/shell/avmplus
    |_ Socket.as 

}}}

The hardest part in all those layers is to balance how much in each layer you implement stuff so the final user (you!) has enough freedom to work with the API.

So if you compare [http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/Socket.html `flash.net::Socket`] with `avmplus::Socket`, not saying that I did a better job than Adobe, but I kept my focus on giving as much low level access to the socket as possible,
and so if you compare the two `avmplus::Socket` is much more lower level which is at the same time good and bad.

It's bad because you don't have all the luxuries of `flash.net::Socket`, no events, not based on `IDataOutput`/`IDataInput`, much less example on the web, etc.

it's good because with `avmplus::Socket` you can fully re-implements `flash.net::Socket` (without the need to have access to the native source code),
and it does not stop there, you can also fully implements `flash.net::DatagramSocket`, `flash.net::ServerSocket`, etc.

And it could be considered "better" as you can fully copy C/C++ socket examples and apply them in AS3.

for example, let's implement a basic TCP server as shown here [http://en.wikipedia.org/wiki/Berkeley_sockets#Server]
{{{
//server.as
import avmplus.System;
import avmplus.Socket;
import C.stdlib.*;
import C.socket.*;

var SocketFD:Socket = new Socket();
//you could also use
//var SocketFD:Socket = new Socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

if( !SocketFD.valid )
{
    trace( "can not create socket" );
    System.exit( EXIT_FAILURE );
}

SocketFD.bind( 1100 );
if( !SocketFD.bound )
{
    trace( "error bind failed" );
    SocketFD.close();
    System.exit( EXIT_FAILURE );
}

SocketFD.listen( 10 );
if( !SocketFD.listening )
{
    trace( "error listen failed" );
    SocketFD.close();
    System.exit( EXIT_FAILURE );
}


var ConnectFD:Socket;
for(;;)
{
    ConnectFD = SocketFD.accept();

    if( !ConnectFD.valid )
    {
        trace( "error accept failed" );
        SocketFD.close();
        System.exit( EXIT_FAILURE );
    }

    /* perform read write operations ...
    var data:String = ConnectFD.receive( buff ); */

    ConnectFD.close();

    if( Socket.lastError > 0 )
    {
        trace( Socket.getErrorMessage( Socket.lastError ) );
        System.exit( EXIT_FAILURE );
    }
}

System.exit( EXIT_SUCCESS );

}}}

you could test it like that
{{{
$ java -jar asc.jar -AS3 -strict -import builtin.abc -import toplevel.abc server.a
./redshell_d server.abc
}}}

and use netcat for the client
{{{
$ nc -v -v 127.0.0.1 1100
localhost [127.0.0.1] 1100 (mctp) open
 sent 0, rcvd 0

$ nc -v -v 127.0.0.1 1100
localhost [127.0.0.1] 1100 (mctp) open
 sent 0, rcvd 0

}}}

in the output you will see
{{{
Socket (4): stream socket created.
Socket (4): Bound to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] listening (backlog=10).
Socket (5): stream socket created.
Socket (5): [127.0.0.1:62838] connected to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] accept connection from [5].
Socket (5): Terminated.
Socket (5): Disconnected from [127.0.0.1:1100].
Socket (5): stream socket destroyed.
Socket (5): stream socket created.
Socket (5): [127.0.0.1:62840] connected to [127.0.0.1:1100].
Socket (4): [127.0.0.1:1100] accept connection from [5].
Socket (5): Terminated.
Socket (5): Disconnected from [127.0.0.1:1100].
Socket (5): stream socket destroyed.
^C
}}}


Here what turned out pretty well in the implementation
  * most if not all of the [http://en.wikipedia.org/wiki/Berkeley_sockets Berkely sockets] function map to a Class
  * it works exactly the same cross platform (at least Windows, Linux Ubuntu-like, OSX; probably more but I lack ressources to test more systems)
  * the API does not hide too many stuff in the background but it still make things simpler than writing it in C

But even with that I had to make hard choices

simply because of the difference between C/C++ and AS3
for example, a lot of berkely sockets function return an integer and need to be passed a `struct sockaddr_in` as arguments
and I decided to avoid that, in most case for functions like `connect()`, `bind()`, `listen()`, it makes thing easier for the user
in other cases for functions like `recv()`, `send()` it makes things harder for the implementer

in short, if some function returns `-1` to show something went wrong, I just return a boolean

Things got more interesting with functions like `recv()`
so what does this function ?
[http://pubs.opengroup.org/onlinepubs/007904975/functions/recv.html recv - receive a message from a connected socket]

here its signature
{{{
ssize_t recv(int socket, void *buffer, size_t length, int flags);
}}}


